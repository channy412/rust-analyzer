//! Generated by `sourcegen_vst`, do not edit by hand.

#![allow(non_snake_case)]
use crate::{
    ast::{self, support, traits::*, AstChildren, AstNode},
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
};
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    ident_token: Option<String>,
    self_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameRef {
    ident_token: Option<String>,
    self_token: bool,
    super_token: bool,
    crate_token: bool,
    Self_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Lifetime {
    lifetime_ident_token: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Path {
    pub qualifier: Option<Box<Path>>,
    coloncolon_token: bool,
    pub segment: Box<PathSegment>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathSegment {
    coloncolon_token: bool,
    pub name_ref: Box<NameRef>,
    pub generic_arg_list: Option<Box<GenericArgList>>,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    l_angle_token: bool,
    pub path_type: Option<Box<PathType>>,
    as_token: bool,
    r_angle_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GenericArgList {
    coloncolon_token: bool,
    l_angle_token: bool,
    pub generic_args: Vec<GenericArg>,
    r_angle_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParamList {
    l_paren_token: bool,
    pub self_param: Option<Box<SelfParam>>,
    comma_token: bool,
    pub params: Vec<Param>,
    r_paren_token: bool,
    pipe_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RetType {
    thin_arrow_token: bool,
    tracked_token: bool,
    l_paren_token: bool,
    pub pat: Option<Box<Pat>>,
    colon_token: bool,
    pub ty: Box<Type>,
    r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathType {
    pub path: Box<Path>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeArg {
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssocTypeArg {
    pub name_ref: Box<NameRef>,
    pub generic_arg_list: Option<Box<GenericArgList>>,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    colon_token: bool,
    pub type_bound_list: Box<TypeBoundList>,
    eq_token: bool,
    pub ty: Box<Type>,
    pub const_arg: Option<Box<ConstArg>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LifetimeArg {
    pub lifetime: Box<Lifetime>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstArg {
    pub expr: Box<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeBoundList {
    pub bounds: Vec<TypeBound>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroCall {
    pub attrs: Vec<Attr>,
    pub path: Box<Path>,
    excl_token: bool,
    pub token_tree: Box<TokenTree>,
    semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Attr {
    pound_token: bool,
    excl_token: bool,
    l_brack_token: bool,
    pub meta: Box<Meta>,
    r_brack_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TokenTree {
    l_paren_token: bool,
    r_paren_token: bool,
    l_curly_token: bool,
    r_curly_token: bool,
    l_brack_token: bool,
    r_brack_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroItems {
    pub items: Vec<Item>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroStmts {
    pub statements: Vec<Stmt>,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    shebang_token: bool,
    pub attrs: Vec<Attr>,
    pub items: Vec<Item>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Const {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    default_token: bool,
    const_token: bool,
    pub name: Option<Box<Name>>,
    underscore_token: bool,
    colon_token: bool,
    pub ty: Box<Type>,
    eq_token: bool,
    pub body: Option<Box<Expr>>,
    semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Enum {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    enum_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub variant_list: Box<VariantList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternBlock {
    pub attrs: Vec<Attr>,
    unsafe_token: bool,
    pub abi: Box<Abi>,
    pub extern_item_list: Box<ExternItemList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternCrate {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    extern_token: bool,
    crate_token: bool,
    pub name_ref: Box<NameRef>,
    pub rename: Option<Box<Rename>>,
    semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Fn {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub publish: Option<Box<Publish>>,
    default_token: bool,
    const_token: bool,
    async_token: bool,
    unsafe_token: bool,
    pub abi: Option<Box<Abi>>,
    pub fn_mode: Option<Box<FnMode>>,
    fn_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub requires_clause: Option<Box<RequiresClause>>,
    pub recommends_clause: Option<Box<RecommendsClause>>,
    pub ensures_clause: Option<Box<EnsuresClause>>,
    pub decreases_clause: Option<Box<DecreasesClause>>,
    pub body: Option<Box<BlockExpr>>,
    semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Impl {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    default_token: bool,
    unsafe_token: bool,
    impl_token: bool,
    pub generic_param_list: Option<Box<GenericParamList>>,
    const_token: bool,
    excl_token: bool,
    for_token: bool,
    pub where_clause: Option<Box<WhereClause>>,
    pub assoc_item_list: Box<AssocItemList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroRules {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    macro_rules_token: bool,
    excl_token: bool,
    pub name: Box<Name>,
    pub token_tree: Box<TokenTree>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroDef {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    macro_token: bool,
    pub name: Box<Name>,
    pub args: Option<Box<TokenTree>>,
    pub body: Box<TokenTree>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Module {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    mod_token: bool,
    pub name: Box<Name>,
    pub item_list: Option<Box<ItemList>>,
    semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Static {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    static_token: bool,
    mut_token: bool,
    pub name: Box<Name>,
    colon_token: bool,
    pub ty: Box<Type>,
    eq_token: bool,
    pub body: Option<Box<Expr>>,
    semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Struct {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub data_mode: Option<Box<DataMode>>,
    struct_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub where_clause: Option<Box<WhereClause>>,
    semicolon_token: bool,
    pub field_list: Option<Box<FieldList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Trait {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    unsafe_token: bool,
    auto_token: bool,
    trait_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    colon_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub assoc_item_list: Box<AssocItemList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TraitAlias {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    trait_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    eq_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
    pub where_clause: Option<Box<WhereClause>>,
    semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeAlias {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    default_token: bool,
    type_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    colon_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
    pub where_clause: Option<Box<WhereClause>>,
    eq_token: bool,
    pub ty: Option<Box<Type>>,
    semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Union {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    union_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub record_field_list: Box<RecordFieldList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Use {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    use_token: bool,
    pub use_tree: Box<UseTree>,
    semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Visibility {
    pub_token: bool,
    l_paren_token: bool,
    in_token: bool,
    pub path: Option<Box<Path>>,
    r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ItemList {
    l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub items: Vec<Item>,
    r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Rename {
    as_token: bool,
    pub name: Option<Box<Name>>,
    underscore_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseTree {
    pub path: Option<Box<Path>>,
    coloncolon_token: bool,
    star_token: bool,
    pub use_tree_list: Option<Box<UseTreeList>>,
    pub rename: Option<Box<Rename>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseTreeList {
    l_curly_token: bool,
    pub use_trees: Vec<UseTree>,
    r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Publish {
    closed_token: bool,
    open_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Abi {
    extern_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnMode {
    spec_token: bool,
    proof_token: bool,
    exec_token: bool,
    pub mode_spec_checked: Option<Box<ModeSpecChecked>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GenericParamList {
    l_angle_token: bool,
    pub generic_params: Vec<GenericParam>,
    r_angle_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhereClause {
    where_token: bool,
    pub predicates: Vec<WherePred>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RequiresClause {
    requires_token: bool,
    pub exprs: Vec<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecommendsClause {
    recommends_token: bool,
    pub exprs: Vec<Expr>,
    via_token: bool,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnsuresClause {
    ensures_token: bool,
    pub exprs: Vec<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DecreasesClause {
    decreases_token: bool,
    pub exprs: Vec<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockExpr {
    pub attrs: Vec<Attr>,
    pub label: Option<Box<Label>>,
    try_token: bool,
    unsafe_token: bool,
    async_token: bool,
    const_token: bool,
    pub stmt_list: Box<StmtList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelfParam {
    pub attrs: Vec<Attr>,
    amp_token: bool,
    pub lifetime: Option<Box<Lifetime>>,
    mut_token: bool,
    pub name: Box<Name>,
    colon_token: bool,
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Param {
    pub attrs: Vec<Attr>,
    tracked_token: bool,
    pub pat: Option<Box<Pat>>,
    colon_token: bool,
    pub ty: Option<Box<Type>>,
    dotdotdot_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DataMode {
    ghost_token: bool,
    tracked_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordFieldList {
    l_curly_token: bool,
    pub fields: Vec<RecordField>,
    r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleFieldList {
    l_paren_token: bool,
    pub fields: Vec<TupleField>,
    r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordField {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub data_mode: Option<Box<DataMode>>,
    pub name: Box<Name>,
    colon_token: bool,
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleField {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariantList {
    l_curly_token: bool,
    pub variants: Vec<Variant>,
    r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Variant {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub name: Box<Name>,
    pub field_list: Option<Box<FieldList>>,
    eq_token: bool,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssocItemList {
    l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub assoc_items: Vec<AssocItem>,
    r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternItemList {
    l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub extern_items: Vec<ExternItem>,
    r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstParam {
    pub attrs: Vec<Attr>,
    const_token: bool,
    pub name: Box<Name>,
    colon_token: bool,
    pub ty: Box<Type>,
    eq_token: bool,
    pub default_val: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LifetimeParam {
    pub attrs: Vec<Attr>,
    pub lifetime: Box<Lifetime>,
    colon_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParam {
    pub attrs: Vec<Attr>,
    pub name: Box<Name>,
    colon_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
    eq_token: bool,
    pub default_type: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WherePred {
    for_token: bool,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub lifetime: Option<Box<Lifetime>>,
    pub ty: Option<Box<Type>>,
    colon_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Meta {
    pub path: Box<Path>,
    eq_token: bool,
    pub expr: Option<Box<Expr>>,
    pub token_tree: Option<Box<TokenTree>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub expr: Box<Expr>,
    semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetStmt {
    pub attrs: Vec<Attr>,
    let_token: bool,
    ghost_token: bool,
    tracked_token: bool,
    pub pat: Option<Box<Pat>>,
    colon_token: bool,
    pub ty: Option<Box<Type>>,
    eq_token: bool,
    pub initializer: Box<Expr>,
    pub let_else: Option<Box<LetElse>>,
    semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetElse {
    else_token: bool,
    pub block_expr: Box<BlockExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayExpr {
    pub attrs: Vec<Attr>,
    l_brack_token: bool,
    pub exprs: Vec<Expr>,
    pub expr: Box<Expr>,
    semicolon_token: bool,
    r_brack_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AwaitExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    dot_token: bool,
    await_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr {
    pub attrs: Vec<Attr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BoxExpr {
    pub attrs: Vec<Attr>,
    box_token: bool,
    pub expr: Box<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakExpr {
    pub attrs: Vec<Attr>,
    break_token: bool,
    pub lifetime: Option<Box<Lifetime>>,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub arg_list: Box<ArgList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CastExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    as_token: bool,
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClosureExpr {
    pub attrs: Vec<Attr>,
    for_token: bool,
    pub generic_param_list: Option<Box<GenericParamList>>,
    const_token: bool,
    static_token: bool,
    async_token: bool,
    move_token: bool,
    forall_token: bool,
    exists_token: bool,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    pub body: Box<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueExpr {
    pub attrs: Vec<Attr>,
    continue_token: bool,
    pub lifetime: Option<Box<Lifetime>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FieldExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    dot_token: bool,
    pub name_ref: Box<NameRef>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForExpr {
    pub attrs: Vec<Attr>,
    pub label: Option<Box<Label>>,
    for_token: bool,
    pub pat: Option<Box<Pat>>,
    in_token: bool,
    pub loop_body: Box<BlockExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfExpr {
    pub attrs: Vec<Attr>,
    if_token: bool,
    else_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr {
    pub attrs: Vec<Attr>,
    l_brack_token: bool,
    r_brack_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub attrs: Vec<Attr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LoopExpr {
    pub attrs: Vec<Attr>,
    pub label: Option<Box<Label>>,
    loop_token: bool,
    pub loop_body: Box<BlockExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroExpr {
    pub macro_call: Box<MacroCall>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchExpr {
    pub attrs: Vec<Attr>,
    match_token: bool,
    pub expr: Box<Expr>,
    pub match_arm_list: Box<MatchArmList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodCallExpr {
    pub attrs: Vec<Attr>,
    pub receiver: Box<Expr>,
    dot_token: bool,
    pub name_ref: Box<NameRef>,
    pub generic_arg_list: Option<Box<GenericArgList>>,
    pub arg_list: Box<ArgList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr {
    pub attrs: Vec<Attr>,
    l_paren_token: bool,
    pub expr: Box<Expr>,
    r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathExpr {
    pub attrs: Vec<Attr>,
    pub path: Box<Path>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExpr {
    pub attrs: Vec<Attr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordExpr {
    pub path: Box<Path>,
    pub record_expr_field_list: Box<RecordExprFieldList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefExpr {
    pub attrs: Vec<Attr>,
    amp_token: bool,
    raw_token: bool,
    mut_token: bool,
    const_token: bool,
    pub expr: Box<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnExpr {
    pub attrs: Vec<Attr>,
    return_token: bool,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    question_mark_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleExpr {
    pub attrs: Vec<Attr>,
    l_paren_token: bool,
    pub fields: Vec<Expr>,
    r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr {
    pub attrs: Vec<Attr>,
    pub label: Option<Box<Label>>,
    while_token: bool,
    pub invariant_clause: Option<Box<InvariantClause>>,
    pub decreases_clause: Option<Box<DecreasesClause>>,
    pub loop_body: Box<BlockExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct YieldExpr {
    pub attrs: Vec<Attr>,
    yield_token: bool,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct YeetExpr {
    pub attrs: Vec<Attr>,
    do_token: bool,
    yeet_token: bool,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetExpr {
    pub attrs: Vec<Attr>,
    let_token: bool,
    pub pat: Option<Box<Pat>>,
    eq_token: bool,
    pub expr: Box<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnderscoreExpr {
    pub attrs: Vec<Attr>,
    underscore_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ViewExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    at_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssertExpr {
    pub attrs: Vec<Attr>,
    assert_token: bool,
    l_paren_token: bool,
    pub expr: Box<Expr>,
    r_paren_token: bool,
    by_token: bool,
    pub name: Option<Box<Name>>,
    pub requires_clause: Option<Box<RequiresClause>>,
    pub block_expr: Option<Box<BlockExpr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssumeExpr {
    pub attrs: Vec<Attr>,
    assume_token: bool,
    l_paren_token: bool,
    pub expr: Box<Expr>,
    r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssertForallExpr {
    pub attrs: Vec<Attr>,
    assert_token: bool,
    forall_token: bool,
    pub closure_expr: Box<ClosureExpr>,
    implies_token: bool,
    pub expr: Option<Box<Expr>>,
    by_token: bool,
    pub block_expr: Box<BlockExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StmtList {
    l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub statements: Vec<Stmt>,
    pub tail_expr: Option<Box<Expr>>,
    r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Label {
    pub lifetime: Box<Lifetime>,
    colon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordExprFieldList {
    l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub fields: Vec<RecordExprField>,
    dotdot_token: bool,
    pub spread: Option<Box<Expr>>,
    r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordExprField {
    pub attrs: Vec<Attr>,
    pub name_ref: Option<Box<NameRef>>,
    colon_token: bool,
    pub expr: Box<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgList {
    l_paren_token: bool,
    pub args: Vec<Expr>,
    r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InvariantClause {
    invariant_token: bool,
    pub exprs: Vec<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArmList {
    l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub arms: Vec<MatchArm>,
    r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArm {
    pub attrs: Vec<Attr>,
    pub pat: Option<Box<Pat>>,
    pub guard: Option<Box<MatchGuard>>,
    fat_arrow_token: bool,
    pub expr: Box<Expr>,
    comma_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchGuard {
    if_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayType {
    l_brack_token: bool,
    pub ty: Box<Type>,
    semicolon_token: bool,
    pub expr: Box<Expr>,
    r_brack_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DynTraitType {
    dyn_token: bool,
    pub type_bound_list: Box<TypeBoundList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnPtrType {
    const_token: bool,
    async_token: bool,
    unsafe_token: bool,
    pub abi: Option<Box<Abi>>,
    fn_token: bool,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForType {
    for_token: bool,
    pub generic_param_list: Box<GenericParamList>,
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImplTraitType {
    impl_token: bool,
    pub type_bound_list: Box<TypeBoundList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InferType {
    underscore_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroType {
    pub macro_call: Box<MacroCall>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NeverType {
    excl_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenType {
    l_paren_token: bool,
    pub ty: Box<Type>,
    r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PtrType {
    star_token: bool,
    const_token: bool,
    mut_token: bool,
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefType {
    amp_token: bool,
    pub lifetime: Option<Box<Lifetime>>,
    mut_token: bool,
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SliceType {
    l_brack_token: bool,
    pub ty: Box<Type>,
    r_brack_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleType {
    l_paren_token: bool,
    pub fields: Vec<Type>,
    r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeBound {
    pub lifetime: Option<Box<Lifetime>>,
    question_mark_token: bool,
    tilde_token: bool,
    const_token: bool,
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentPat {
    pub attrs: Vec<Attr>,
    ref_token: bool,
    mut_token: bool,
    pub name: Box<Name>,
    at_token: bool,
    pub pat: Option<Box<Pat>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BoxPat {
    box_token: bool,
    pub pat: Option<Box<Pat>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RestPat {
    pub attrs: Vec<Attr>,
    dotdot_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralPat {
    minus_token: bool,
    pub literal: Box<Literal>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroPat {
    pub macro_call: Box<MacroCall>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OrPat {
    pub pats: Vec<Pat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenPat {
    l_paren_token: bool,
    pub pat: Option<Box<Pat>>,
    r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathPat {
    pub path: Box<Path>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WildcardPat {
    underscore_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangePat {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordPat {
    pub path: Box<Path>,
    pub record_pat_field_list: Box<RecordPatFieldList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefPat {
    amp_token: bool,
    mut_token: bool,
    pub pat: Option<Box<Pat>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SlicePat {
    l_brack_token: bool,
    pub pats: Vec<Pat>,
    r_brack_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TuplePat {
    l_paren_token: bool,
    pub fields: Vec<Pat>,
    r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleStructPat {
    pub path: Box<Path>,
    l_paren_token: bool,
    pub fields: Vec<Pat>,
    r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstBlockPat {
    const_token: bool,
    pub block_expr: Box<BlockExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordPatFieldList {
    l_curly_token: bool,
    pub fields: Vec<RecordPatField>,
    pub rest_pat: Option<Box<RestPat>>,
    r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordPatField {
    pub attrs: Vec<Attr>,
    pub name_ref: Option<Box<NameRef>>,
    colon_token: bool,
    pub pat: Option<Box<Pat>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModeSpecChecked {
    spec_token: bool,
    l_paren_token: bool,
    checked_token: bool,
    r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SignatureDecreases {
    pub decreases_clause: Box<DecreasesClause>,
    when_token: bool,
    pub expr: Option<Box<Expr>>,
    via_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Prover {
    by_token: bool,
    l_paren_token: bool,
    pub name: Box<Name>,
    r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TriggerAttribute {
    pound_token: bool,
    excl_token: bool,
    l_brack_token: bool,
    trigger_token: bool,
    pub exprs: Vec<Expr>,
    r_brack_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum GenericArg {
    TypeArg(Box<TypeArg>),
    AssocTypeArg(Box<AssocTypeArg>),
    LifetimeArg(Box<LifetimeArg>),
    ConstArg(Box<ConstArg>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    ArrayType(Box<ArrayType>),
    DynTraitType(Box<DynTraitType>),
    FnPtrType(Box<FnPtrType>),
    ForType(Box<ForType>),
    ImplTraitType(Box<ImplTraitType>),
    InferType(Box<InferType>),
    MacroType(Box<MacroType>),
    NeverType(Box<NeverType>),
    ParenType(Box<ParenType>),
    PathType(Box<PathType>),
    PtrType(Box<PtrType>),
    RefType(Box<RefType>),
    SliceType(Box<SliceType>),
    TupleType(Box<TupleType>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    ArrayExpr(Box<ArrayExpr>),
    AwaitExpr(Box<AwaitExpr>),
    BinExpr(Box<BinExpr>),
    BlockExpr(Box<BlockExpr>),
    BoxExpr(Box<BoxExpr>),
    BreakExpr(Box<BreakExpr>),
    CallExpr(Box<CallExpr>),
    CastExpr(Box<CastExpr>),
    ClosureExpr(Box<ClosureExpr>),
    ContinueExpr(Box<ContinueExpr>),
    FieldExpr(Box<FieldExpr>),
    ForExpr(Box<ForExpr>),
    IfExpr(Box<IfExpr>),
    IndexExpr(Box<IndexExpr>),
    Literal(Box<Literal>),
    LoopExpr(Box<LoopExpr>),
    MacroExpr(Box<MacroExpr>),
    MatchExpr(Box<MatchExpr>),
    MethodCallExpr(Box<MethodCallExpr>),
    ParenExpr(Box<ParenExpr>),
    PathExpr(Box<PathExpr>),
    PrefixExpr(Box<PrefixExpr>),
    RangeExpr(Box<RangeExpr>),
    RecordExpr(Box<RecordExpr>),
    RefExpr(Box<RefExpr>),
    ReturnExpr(Box<ReturnExpr>),
    TryExpr(Box<TryExpr>),
    TupleExpr(Box<TupleExpr>),
    WhileExpr(Box<WhileExpr>),
    YieldExpr(Box<YieldExpr>),
    YeetExpr(Box<YeetExpr>),
    LetExpr(Box<LetExpr>),
    UnderscoreExpr(Box<UnderscoreExpr>),
    ViewExpr(Box<ViewExpr>),
    AssertExpr(Box<AssertExpr>),
    AssumeExpr(Box<AssumeExpr>),
    AssertForallExpr(Box<AssertForallExpr>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Item {
    Const(Box<Const>),
    Enum(Box<Enum>),
    ExternBlock(Box<ExternBlock>),
    ExternCrate(Box<ExternCrate>),
    Fn(Box<Fn>),
    Impl(Box<Impl>),
    MacroCall(Box<MacroCall>),
    MacroRules(Box<MacroRules>),
    MacroDef(Box<MacroDef>),
    Module(Box<Module>),
    Static(Box<Static>),
    Struct(Box<Struct>),
    Trait(Box<Trait>),
    TraitAlias(Box<TraitAlias>),
    TypeAlias(Box<TypeAlias>),
    Union(Box<Union>),
    Use(Box<Use>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    ExprStmt(Box<ExprStmt>),
    Item(Box<Item>),
    LetStmt(Box<LetStmt>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Pat {
    IdentPat(Box<IdentPat>),
    BoxPat(Box<BoxPat>),
    RestPat(Box<RestPat>),
    LiteralPat(Box<LiteralPat>),
    MacroPat(Box<MacroPat>),
    OrPat(Box<OrPat>),
    ParenPat(Box<ParenPat>),
    PathPat(Box<PathPat>),
    WildcardPat(Box<WildcardPat>),
    RangePat(Box<RangePat>),
    RecordPat(Box<RecordPat>),
    RefPat(Box<RefPat>),
    SlicePat(Box<SlicePat>),
    TuplePat(Box<TuplePat>),
    TupleStructPat(Box<TupleStructPat>),
    ConstBlockPat(Box<ConstBlockPat>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FieldList {
    RecordFieldList(Box<RecordFieldList>),
    TupleFieldList(Box<TupleFieldList>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Adt {
    Enum(Box<Enum>),
    Struct(Box<Struct>),
    Union(Box<Union>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AssocItem {
    Const(Box<Const>),
    Fn(Box<Fn>),
    MacroCall(Box<MacroCall>),
    TypeAlias(Box<TypeAlias>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ExternItem {
    Fn(Box<Fn>),
    MacroCall(Box<MacroCall>),
    Static(Box<Static>),
    TypeAlias(Box<TypeAlias>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum GenericParam {
    ConstParam(Box<ConstParam>),
    LifetimeParam(Box<LifetimeParam>),
    TypeParam(Box<TypeParam>),
}
impl TryFrom<super::nodes::Name> for Name {
    type Error = String;
    fn try_from(item: super::nodes::Name) -> Result<Self, Self::Error> {
        Ok(Self {
            ident_token: item.ident_token().map(|it| it.text().to_string()),
            self_token: item.self_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::NameRef> for NameRef {
    type Error = String;
    fn try_from(item: super::nodes::NameRef) -> Result<Self, Self::Error> {
        Ok(Self {
            ident_token: item.ident_token().map(|it| it.text().to_string()),
            self_token: item.self_token().is_some(),
            super_token: item.super_token().is_some(),
            crate_token: item.crate_token().is_some(),
            Self_token: item.Self_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Lifetime> for Lifetime {
    type Error = String;
    fn try_from(item: super::nodes::Lifetime) -> Result<Self, Self::Error> {
        Ok(Self {
            lifetime_ident_token: item.lifetime_ident_token().map(|it| it.text().to_string()),
        })
    }
}
impl TryFrom<super::nodes::Path> for Path {
    type Error = String;
    fn try_from(item: super::nodes::Path) -> Result<Self, Self::Error> {
        Ok(Self {
            qualifier: match item.qualifier() {
                Some(it) => Some(Box::new(Path::try_from(it)?)),
                None => None,
            },
            coloncolon_token: item.coloncolon_token().is_some(),
            segment: Box::new(
                item.segment()
                    .ok_or(format!("{}", stringify!(segment)))
                    .map(|it| PathSegment::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::PathSegment> for PathSegment {
    type Error = String;
    fn try_from(item: super::nodes::PathSegment) -> Result<Self, Self::Error> {
        Ok(Self {
            coloncolon_token: item.coloncolon_token().is_some(),
            name_ref: Box::new(
                item.name_ref()
                    .ok_or(format!("{}", stringify!(name_ref)))
                    .map(|it| NameRef::try_from(it))??,
            ),
            generic_arg_list: match item.generic_arg_list() {
                Some(it) => Some(Box::new(GenericArgList::try_from(it)?)),
                None => None,
            },
            param_list: match item.param_list() {
                Some(it) => Some(Box::new(ParamList::try_from(it)?)),
                None => None,
            },
            ret_type: match item.ret_type() {
                Some(it) => Some(Box::new(RetType::try_from(it)?)),
                None => None,
            },
            l_angle_token: item.l_angle_token().is_some(),
            path_type: match item.path_type() {
                Some(it) => Some(Box::new(PathType::try_from(it)?)),
                None => None,
            },
            as_token: item.as_token().is_some(),
            r_angle_token: item.r_angle_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::GenericArgList> for GenericArgList {
    type Error = String;
    fn try_from(item: super::nodes::GenericArgList) -> Result<Self, Self::Error> {
        Ok(Self {
            coloncolon_token: item.coloncolon_token().is_some(),
            l_angle_token: item.l_angle_token().is_some(),
            generic_args: item
                .generic_args()
                .into_iter()
                .map(GenericArg::try_from)
                .collect::<Result<Vec<GenericArg>, String>>()?,
            r_angle_token: item.r_angle_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::ParamList> for ParamList {
    type Error = String;
    fn try_from(item: super::nodes::ParamList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            self_param: match item.self_param() {
                Some(it) => Some(Box::new(SelfParam::try_from(it)?)),
                None => None,
            },
            comma_token: item.comma_token().is_some(),
            params: item
                .params()
                .into_iter()
                .map(Param::try_from)
                .collect::<Result<Vec<Param>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
            pipe_token: item.pipe_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::RetType> for RetType {
    type Error = String;
    fn try_from(item: super::nodes::RetType) -> Result<Self, Self::Error> {
        Ok(Self {
            thin_arrow_token: item.thin_arrow_token().is_some(),
            tracked_token: item.tracked_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::PathType> for PathType {
    type Error = String;
    fn try_from(item: super::nodes::PathType) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::TypeArg> for TypeArg {
    type Error = String;
    fn try_from(item: super::nodes::TypeArg) -> Result<Self, Self::Error> {
        Ok(Self {
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::AssocTypeArg> for AssocTypeArg {
    type Error = String;
    fn try_from(item: super::nodes::AssocTypeArg) -> Result<Self, Self::Error> {
        Ok(Self {
            name_ref: Box::new(
                item.name_ref()
                    .ok_or(format!("{}", stringify!(name_ref)))
                    .map(|it| NameRef::try_from(it))??,
            ),
            generic_arg_list: match item.generic_arg_list() {
                Some(it) => Some(Box::new(GenericArgList::try_from(it)?)),
                None => None,
            },
            param_list: match item.param_list() {
                Some(it) => Some(Box::new(ParamList::try_from(it)?)),
                None => None,
            },
            ret_type: match item.ret_type() {
                Some(it) => Some(Box::new(RetType::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            type_bound_list: Box::new(
                item.type_bound_list()
                    .ok_or(format!("{}", stringify!(type_bound_list)))
                    .map(|it| TypeBoundList::try_from(it))??,
            ),
            eq_token: item.eq_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
            const_arg: match item.const_arg() {
                Some(it) => Some(Box::new(ConstArg::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::LifetimeArg> for LifetimeArg {
    type Error = String;
    fn try_from(item: super::nodes::LifetimeArg) -> Result<Self, Self::Error> {
        Ok(Self {
            lifetime: Box::new(
                item.lifetime()
                    .ok_or(format!("{}", stringify!(lifetime)))
                    .map(|it| Lifetime::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ConstArg> for ConstArg {
    type Error = String;
    fn try_from(item: super::nodes::ConstArg) -> Result<Self, Self::Error> {
        Ok(Self {
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::TypeBoundList> for TypeBoundList {
    type Error = String;
    fn try_from(item: super::nodes::TypeBoundList) -> Result<Self, Self::Error> {
        Ok(Self {
            bounds: item
                .bounds()
                .into_iter()
                .map(TypeBound::try_from)
                .collect::<Result<Vec<TypeBound>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::MacroCall> for MacroCall {
    type Error = String;
    fn try_from(item: super::nodes::MacroCall) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            excl_token: item.excl_token().is_some(),
            token_tree: Box::new(
                item.token_tree()
                    .ok_or(format!("{}", stringify!(token_tree)))
                    .map(|it| TokenTree::try_from(it))??,
            ),
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Attr> for Attr {
    type Error = String;
    fn try_from(item: super::nodes::Attr) -> Result<Self, Self::Error> {
        Ok(Self {
            pound_token: item.pound_token().is_some(),
            excl_token: item.excl_token().is_some(),
            l_brack_token: item.l_brack_token().is_some(),
            meta: Box::new(
                item.meta()
                    .ok_or(format!("{}", stringify!(meta)))
                    .map(|it| Meta::try_from(it))??,
            ),
            r_brack_token: item.r_brack_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TokenTree> for TokenTree {
    type Error = String;
    fn try_from(item: super::nodes::TokenTree) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            r_paren_token: item.r_paren_token().is_some(),
            l_curly_token: item.l_curly_token().is_some(),
            r_curly_token: item.r_curly_token().is_some(),
            l_brack_token: item.l_brack_token().is_some(),
            r_brack_token: item.r_brack_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::MacroItems> for MacroItems {
    type Error = String;
    fn try_from(item: super::nodes::MacroItems) -> Result<Self, Self::Error> {
        Ok(Self {
            items: item
                .items()
                .into_iter()
                .map(Item::try_from)
                .collect::<Result<Vec<Item>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::MacroStmts> for MacroStmts {
    type Error = String;
    fn try_from(item: super::nodes::MacroStmts) -> Result<Self, Self::Error> {
        Ok(Self {
            statements: item
                .statements()
                .into_iter()
                .map(Stmt::try_from)
                .collect::<Result<Vec<Stmt>, String>>()?,
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::SourceFile> for SourceFile {
    type Error = String;
    fn try_from(item: super::nodes::SourceFile) -> Result<Self, Self::Error> {
        Ok(Self {
            shebang_token: item.shebang_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            items: item
                .items()
                .into_iter()
                .map(Item::try_from)
                .collect::<Result<Vec<Item>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::Const> for Const {
    type Error = String;
    fn try_from(item: super::nodes::Const) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            default_token: item.default_token().is_some(),
            const_token: item.const_token().is_some(),
            name: match item.name() {
                Some(it) => Some(Box::new(Name::try_from(it)?)),
                None => None,
            },
            underscore_token: item.underscore_token().is_some(),
            colon_token: item.colon_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
            eq_token: item.eq_token().is_some(),
            body: match item.body() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Enum> for Enum {
    type Error = String;
    fn try_from(item: super::nodes::Enum) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            enum_token: item.enum_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            variant_list: Box::new(
                item.variant_list()
                    .ok_or(format!("{}", stringify!(variant_list)))
                    .map(|it| VariantList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ExternBlock> for ExternBlock {
    type Error = String;
    fn try_from(item: super::nodes::ExternBlock) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            unsafe_token: item.unsafe_token().is_some(),
            abi: Box::new(
                item.abi().ok_or(format!("{}", stringify!(abi))).map(|it| Abi::try_from(it))??,
            ),
            extern_item_list: Box::new(
                item.extern_item_list()
                    .ok_or(format!("{}", stringify!(extern_item_list)))
                    .map(|it| ExternItemList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ExternCrate> for ExternCrate {
    type Error = String;
    fn try_from(item: super::nodes::ExternCrate) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            extern_token: item.extern_token().is_some(),
            crate_token: item.crate_token().is_some(),
            name_ref: Box::new(
                item.name_ref()
                    .ok_or(format!("{}", stringify!(name_ref)))
                    .map(|it| NameRef::try_from(it))??,
            ),
            rename: match item.rename() {
                Some(it) => Some(Box::new(Rename::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Fn> for Fn {
    type Error = String;
    fn try_from(item: super::nodes::Fn) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            publish: match item.publish() {
                Some(it) => Some(Box::new(Publish::try_from(it)?)),
                None => None,
            },
            default_token: item.default_token().is_some(),
            const_token: item.const_token().is_some(),
            async_token: item.async_token().is_some(),
            unsafe_token: item.unsafe_token().is_some(),
            abi: match item.abi() {
                Some(it) => Some(Box::new(Abi::try_from(it)?)),
                None => None,
            },
            fn_mode: match item.fn_mode() {
                Some(it) => Some(Box::new(FnMode::try_from(it)?)),
                None => None,
            },
            fn_token: item.fn_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            param_list: match item.param_list() {
                Some(it) => Some(Box::new(ParamList::try_from(it)?)),
                None => None,
            },
            ret_type: match item.ret_type() {
                Some(it) => Some(Box::new(RetType::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            requires_clause: match item.requires_clause() {
                Some(it) => Some(Box::new(RequiresClause::try_from(it)?)),
                None => None,
            },
            recommends_clause: match item.recommends_clause() {
                Some(it) => Some(Box::new(RecommendsClause::try_from(it)?)),
                None => None,
            },
            ensures_clause: match item.ensures_clause() {
                Some(it) => Some(Box::new(EnsuresClause::try_from(it)?)),
                None => None,
            },
            decreases_clause: match item.decreases_clause() {
                Some(it) => Some(Box::new(DecreasesClause::try_from(it)?)),
                None => None,
            },
            body: match item.body() {
                Some(it) => Some(Box::new(BlockExpr::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Impl> for Impl {
    type Error = String;
    fn try_from(item: super::nodes::Impl) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            default_token: item.default_token().is_some(),
            unsafe_token: item.unsafe_token().is_some(),
            impl_token: item.impl_token().is_some(),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            const_token: item.const_token().is_some(),
            excl_token: item.excl_token().is_some(),
            for_token: item.for_token().is_some(),
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            assoc_item_list: Box::new(
                item.assoc_item_list()
                    .ok_or(format!("{}", stringify!(assoc_item_list)))
                    .map(|it| AssocItemList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::MacroRules> for MacroRules {
    type Error = String;
    fn try_from(item: super::nodes::MacroRules) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            macro_rules_token: item.macro_rules_token().is_some(),
            excl_token: item.excl_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            token_tree: Box::new(
                item.token_tree()
                    .ok_or(format!("{}", stringify!(token_tree)))
                    .map(|it| TokenTree::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::MacroDef> for MacroDef {
    type Error = String;
    fn try_from(item: super::nodes::MacroDef) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            macro_token: item.macro_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            args: match item.args() {
                Some(it) => Some(Box::new(TokenTree::try_from(it)?)),
                None => None,
            },
            body: Box::new(
                item.body()
                    .ok_or(format!("{}", stringify!(body)))
                    .map(|it| TokenTree::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::Module> for Module {
    type Error = String;
    fn try_from(item: super::nodes::Module) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            mod_token: item.mod_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            item_list: match item.item_list() {
                Some(it) => Some(Box::new(ItemList::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Static> for Static {
    type Error = String;
    fn try_from(item: super::nodes::Static) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            static_token: item.static_token().is_some(),
            mut_token: item.mut_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
            eq_token: item.eq_token().is_some(),
            body: match item.body() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Struct> for Struct {
    type Error = String;
    fn try_from(item: super::nodes::Struct) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            data_mode: match item.data_mode() {
                Some(it) => Some(Box::new(DataMode::try_from(it)?)),
                None => None,
            },
            struct_token: item.struct_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
            field_list: match item.field_list() {
                Some(it) => Some(Box::new(FieldList::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::Trait> for Trait {
    type Error = String;
    fn try_from(item: super::nodes::Trait) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            unsafe_token: item.unsafe_token().is_some(),
            auto_token: item.auto_token().is_some(),
            trait_token: item.trait_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            assoc_item_list: Box::new(
                item.assoc_item_list()
                    .ok_or(format!("{}", stringify!(assoc_item_list)))
                    .map(|it| AssocItemList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::TraitAlias> for TraitAlias {
    type Error = String;
    fn try_from(item: super::nodes::TraitAlias) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            trait_token: item.trait_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TypeAlias> for TypeAlias {
    type Error = String;
    fn try_from(item: super::nodes::TypeAlias) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            default_token: item.default_token().is_some(),
            type_token: item.type_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Union> for Union {
    type Error = String;
    fn try_from(item: super::nodes::Union) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            union_token: item.union_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            record_field_list: Box::new(
                item.record_field_list()
                    .ok_or(format!("{}", stringify!(record_field_list)))
                    .map(|it| RecordFieldList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::Use> for Use {
    type Error = String;
    fn try_from(item: super::nodes::Use) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            use_token: item.use_token().is_some(),
            use_tree: Box::new(
                item.use_tree()
                    .ok_or(format!("{}", stringify!(use_tree)))
                    .map(|it| UseTree::try_from(it))??,
            ),
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Visibility> for Visibility {
    type Error = String;
    fn try_from(item: super::nodes::Visibility) -> Result<Self, Self::Error> {
        Ok(Self {
            pub_token: item.pub_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            in_token: item.in_token().is_some(),
            path: match item.path() {
                Some(it) => Some(Box::new(Path::try_from(it)?)),
                None => None,
            },
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::ItemList> for ItemList {
    type Error = String;
    fn try_from(item: super::nodes::ItemList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            items: item
                .items()
                .into_iter()
                .map(Item::try_from)
                .collect::<Result<Vec<Item>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Rename> for Rename {
    type Error = String;
    fn try_from(item: super::nodes::Rename) -> Result<Self, Self::Error> {
        Ok(Self {
            as_token: item.as_token().is_some(),
            name: match item.name() {
                Some(it) => Some(Box::new(Name::try_from(it)?)),
                None => None,
            },
            underscore_token: item.underscore_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::UseTree> for UseTree {
    type Error = String;
    fn try_from(item: super::nodes::UseTree) -> Result<Self, Self::Error> {
        Ok(Self {
            path: match item.path() {
                Some(it) => Some(Box::new(Path::try_from(it)?)),
                None => None,
            },
            coloncolon_token: item.coloncolon_token().is_some(),
            star_token: item.star_token().is_some(),
            use_tree_list: match item.use_tree_list() {
                Some(it) => Some(Box::new(UseTreeList::try_from(it)?)),
                None => None,
            },
            rename: match item.rename() {
                Some(it) => Some(Box::new(Rename::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::UseTreeList> for UseTreeList {
    type Error = String;
    fn try_from(item: super::nodes::UseTreeList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            use_trees: item
                .use_trees()
                .into_iter()
                .map(UseTree::try_from)
                .collect::<Result<Vec<UseTree>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Publish> for Publish {
    type Error = String;
    fn try_from(item: super::nodes::Publish) -> Result<Self, Self::Error> {
        Ok(Self {
            closed_token: item.closed_token().is_some(),
            open_token: item.open_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Abi> for Abi {
    type Error = String;
    fn try_from(item: super::nodes::Abi) -> Result<Self, Self::Error> {
        Ok(Self { extern_token: item.extern_token().is_some() })
    }
}
impl TryFrom<super::nodes::FnMode> for FnMode {
    type Error = String;
    fn try_from(item: super::nodes::FnMode) -> Result<Self, Self::Error> {
        Ok(Self {
            spec_token: item.spec_token().is_some(),
            proof_token: item.proof_token().is_some(),
            exec_token: item.exec_token().is_some(),
            mode_spec_checked: match item.mode_spec_checked() {
                Some(it) => Some(Box::new(ModeSpecChecked::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::GenericParamList> for GenericParamList {
    type Error = String;
    fn try_from(item: super::nodes::GenericParamList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_angle_token: item.l_angle_token().is_some(),
            generic_params: item
                .generic_params()
                .into_iter()
                .map(GenericParam::try_from)
                .collect::<Result<Vec<GenericParam>, String>>()?,
            r_angle_token: item.r_angle_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::WhereClause> for WhereClause {
    type Error = String;
    fn try_from(item: super::nodes::WhereClause) -> Result<Self, Self::Error> {
        Ok(Self {
            where_token: item.where_token().is_some(),
            predicates: item
                .predicates()
                .into_iter()
                .map(WherePred::try_from)
                .collect::<Result<Vec<WherePred>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::RequiresClause> for RequiresClause {
    type Error = String;
    fn try_from(item: super::nodes::RequiresClause) -> Result<Self, Self::Error> {
        Ok(Self {
            requires_token: item.requires_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::RecommendsClause> for RecommendsClause {
    type Error = String;
    fn try_from(item: super::nodes::RecommendsClause) -> Result<Self, Self::Error> {
        Ok(Self {
            recommends_token: item.recommends_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            via_token: item.via_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::EnsuresClause> for EnsuresClause {
    type Error = String;
    fn try_from(item: super::nodes::EnsuresClause) -> Result<Self, Self::Error> {
        Ok(Self {
            ensures_token: item.ensures_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::DecreasesClause> for DecreasesClause {
    type Error = String;
    fn try_from(item: super::nodes::DecreasesClause) -> Result<Self, Self::Error> {
        Ok(Self {
            decreases_token: item.decreases_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::BlockExpr> for BlockExpr {
    type Error = String;
    fn try_from(item: super::nodes::BlockExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            label: match item.label() {
                Some(it) => Some(Box::new(Label::try_from(it)?)),
                None => None,
            },
            try_token: item.try_token().is_some(),
            unsafe_token: item.unsafe_token().is_some(),
            async_token: item.async_token().is_some(),
            const_token: item.const_token().is_some(),
            stmt_list: Box::new(
                item.stmt_list()
                    .ok_or(format!("{}", stringify!(stmt_list)))
                    .map(|it| StmtList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::SelfParam> for SelfParam {
    type Error = String;
    fn try_from(item: super::nodes::SelfParam) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            amp_token: item.amp_token().is_some(),
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
            mut_token: item.mut_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::Param> for Param {
    type Error = String;
    fn try_from(item: super::nodes::Param) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            tracked_token: item.tracked_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            dotdotdot_token: item.dotdotdot_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::DataMode> for DataMode {
    type Error = String;
    fn try_from(item: super::nodes::DataMode) -> Result<Self, Self::Error> {
        Ok(Self {
            ghost_token: item.ghost_token().is_some(),
            tracked_token: item.tracked_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::RecordFieldList> for RecordFieldList {
    type Error = String;
    fn try_from(item: super::nodes::RecordFieldList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(RecordField::try_from)
                .collect::<Result<Vec<RecordField>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TupleFieldList> for TupleFieldList {
    type Error = String;
    fn try_from(item: super::nodes::TupleFieldList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(TupleField::try_from)
                .collect::<Result<Vec<TupleField>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::RecordField> for RecordField {
    type Error = String;
    fn try_from(item: super::nodes::RecordField) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            data_mode: match item.data_mode() {
                Some(it) => Some(Box::new(DataMode::try_from(it)?)),
                None => None,
            },
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::TupleField> for TupleField {
    type Error = String;
    fn try_from(item: super::nodes::TupleField) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::VariantList> for VariantList {
    type Error = String;
    fn try_from(item: super::nodes::VariantList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            variants: item
                .variants()
                .into_iter()
                .map(Variant::try_from)
                .collect::<Result<Vec<Variant>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Variant> for Variant {
    type Error = String;
    fn try_from(item: super::nodes::Variant) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            field_list: match item.field_list() {
                Some(it) => Some(Box::new(FieldList::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::AssocItemList> for AssocItemList {
    type Error = String;
    fn try_from(item: super::nodes::AssocItemList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            assoc_items: item
                .assoc_items()
                .into_iter()
                .map(AssocItem::try_from)
                .collect::<Result<Vec<AssocItem>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::ExternItemList> for ExternItemList {
    type Error = String;
    fn try_from(item: super::nodes::ExternItemList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            extern_items: item
                .extern_items()
                .into_iter()
                .map(ExternItem::try_from)
                .collect::<Result<Vec<ExternItem>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::ConstParam> for ConstParam {
    type Error = String;
    fn try_from(item: super::nodes::ConstParam) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            const_token: item.const_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
            eq_token: item.eq_token().is_some(),
            default_val: match item.default_val() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::LifetimeParam> for LifetimeParam {
    type Error = String;
    fn try_from(item: super::nodes::LifetimeParam) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            lifetime: Box::new(
                item.lifetime()
                    .ok_or(format!("{}", stringify!(lifetime)))
                    .map(|it| Lifetime::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::TypeParam> for TypeParam {
    type Error = String;
    fn try_from(item: super::nodes::TypeParam) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            default_type: match item.default_type() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::WherePred> for WherePred {
    type Error = String;
    fn try_from(item: super::nodes::WherePred) -> Result<Self, Self::Error> {
        Ok(Self {
            for_token: item.for_token().is_some(),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::Meta> for Meta {
    type Error = String;
    fn try_from(item: super::nodes::Meta) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            eq_token: item.eq_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            token_tree: match item.token_tree() {
                Some(it) => Some(Box::new(TokenTree::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::ExprStmt> for ExprStmt {
    type Error = String;
    fn try_from(item: super::nodes::ExprStmt) -> Result<Self, Self::Error> {
        Ok(Self {
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::LetStmt> for LetStmt {
    type Error = String;
    fn try_from(item: super::nodes::LetStmt) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            let_token: item.let_token().is_some(),
            ghost_token: item.ghost_token().is_some(),
            tracked_token: item.tracked_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            initializer: Box::new(
                item.initializer()
                    .ok_or(format!("{}", stringify!(initializer)))
                    .map(|it| Expr::try_from(it))??,
            ),
            let_else: match item.let_else() {
                Some(it) => Some(Box::new(LetElse::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::LetElse> for LetElse {
    type Error = String;
    fn try_from(item: super::nodes::LetElse) -> Result<Self, Self::Error> {
        Ok(Self {
            else_token: item.else_token().is_some(),
            block_expr: Box::new(
                item.block_expr()
                    .ok_or(format!("{}", stringify!(block_expr)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ArrayExpr> for ArrayExpr {
    type Error = String;
    fn try_from(item: super::nodes::ArrayExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            l_brack_token: item.l_brack_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            semicolon_token: item.semicolon_token().is_some(),
            r_brack_token: item.r_brack_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::AwaitExpr> for AwaitExpr {
    type Error = String;
    fn try_from(item: super::nodes::AwaitExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            dot_token: item.dot_token().is_some(),
            await_token: item.await_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::BinExpr> for BinExpr {
    type Error = String;
    fn try_from(item: super::nodes::BinExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::BoxExpr> for BoxExpr {
    type Error = String;
    fn try_from(item: super::nodes::BoxExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            box_token: item.box_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::BreakExpr> for BreakExpr {
    type Error = String;
    fn try_from(item: super::nodes::BreakExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            break_token: item.break_token().is_some(),
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::CallExpr> for CallExpr {
    type Error = String;
    fn try_from(item: super::nodes::CallExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            arg_list: Box::new(
                item.arg_list()
                    .ok_or(format!("{}", stringify!(arg_list)))
                    .map(|it| ArgList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::CastExpr> for CastExpr {
    type Error = String;
    fn try_from(item: super::nodes::CastExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            as_token: item.as_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ClosureExpr> for ClosureExpr {
    type Error = String;
    fn try_from(item: super::nodes::ClosureExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            for_token: item.for_token().is_some(),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            const_token: item.const_token().is_some(),
            static_token: item.static_token().is_some(),
            async_token: item.async_token().is_some(),
            move_token: item.move_token().is_some(),
            forall_token: item.forall_token().is_some(),
            exists_token: item.exists_token().is_some(),
            param_list: match item.param_list() {
                Some(it) => Some(Box::new(ParamList::try_from(it)?)),
                None => None,
            },
            ret_type: match item.ret_type() {
                Some(it) => Some(Box::new(RetType::try_from(it)?)),
                None => None,
            },
            body: Box::new(
                item.body()
                    .ok_or(format!("{}", stringify!(body)))
                    .map(|it| Expr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ContinueExpr> for ContinueExpr {
    type Error = String;
    fn try_from(item: super::nodes::ContinueExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            continue_token: item.continue_token().is_some(),
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::FieldExpr> for FieldExpr {
    type Error = String;
    fn try_from(item: super::nodes::FieldExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            dot_token: item.dot_token().is_some(),
            name_ref: Box::new(
                item.name_ref()
                    .ok_or(format!("{}", stringify!(name_ref)))
                    .map(|it| NameRef::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ForExpr> for ForExpr {
    type Error = String;
    fn try_from(item: super::nodes::ForExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            label: match item.label() {
                Some(it) => Some(Box::new(Label::try_from(it)?)),
                None => None,
            },
            for_token: item.for_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            in_token: item.in_token().is_some(),
            loop_body: Box::new(
                item.loop_body()
                    .ok_or(format!("{}", stringify!(loop_body)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::IfExpr> for IfExpr {
    type Error = String;
    fn try_from(item: super::nodes::IfExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            if_token: item.if_token().is_some(),
            else_token: item.else_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::IndexExpr> for IndexExpr {
    type Error = String;
    fn try_from(item: super::nodes::IndexExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            l_brack_token: item.l_brack_token().is_some(),
            r_brack_token: item.r_brack_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Literal> for Literal {
    type Error = String;
    fn try_from(item: super::nodes::Literal) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::LoopExpr> for LoopExpr {
    type Error = String;
    fn try_from(item: super::nodes::LoopExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            label: match item.label() {
                Some(it) => Some(Box::new(Label::try_from(it)?)),
                None => None,
            },
            loop_token: item.loop_token().is_some(),
            loop_body: Box::new(
                item.loop_body()
                    .ok_or(format!("{}", stringify!(loop_body)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::MacroExpr> for MacroExpr {
    type Error = String;
    fn try_from(item: super::nodes::MacroExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            macro_call: Box::new(
                item.macro_call()
                    .ok_or(format!("{}", stringify!(macro_call)))
                    .map(|it| MacroCall::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::MatchExpr> for MatchExpr {
    type Error = String;
    fn try_from(item: super::nodes::MatchExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            match_token: item.match_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            match_arm_list: Box::new(
                item.match_arm_list()
                    .ok_or(format!("{}", stringify!(match_arm_list)))
                    .map(|it| MatchArmList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::MethodCallExpr> for MethodCallExpr {
    type Error = String;
    fn try_from(item: super::nodes::MethodCallExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            receiver: Box::new(
                item.receiver()
                    .ok_or(format!("{}", stringify!(receiver)))
                    .map(|it| Expr::try_from(it))??,
            ),
            dot_token: item.dot_token().is_some(),
            name_ref: Box::new(
                item.name_ref()
                    .ok_or(format!("{}", stringify!(name_ref)))
                    .map(|it| NameRef::try_from(it))??,
            ),
            generic_arg_list: match item.generic_arg_list() {
                Some(it) => Some(Box::new(GenericArgList::try_from(it)?)),
                None => None,
            },
            arg_list: Box::new(
                item.arg_list()
                    .ok_or(format!("{}", stringify!(arg_list)))
                    .map(|it| ArgList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ParenExpr> for ParenExpr {
    type Error = String;
    fn try_from(item: super::nodes::ParenExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            l_paren_token: item.l_paren_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::PathExpr> for PathExpr {
    type Error = String;
    fn try_from(item: super::nodes::PathExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::PrefixExpr> for PrefixExpr {
    type Error = String;
    fn try_from(item: super::nodes::PrefixExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::RangeExpr> for RangeExpr {
    type Error = String;
    fn try_from(item: super::nodes::RangeExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::RecordExpr> for RecordExpr {
    type Error = String;
    fn try_from(item: super::nodes::RecordExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            record_expr_field_list: Box::new(
                item.record_expr_field_list()
                    .ok_or(format!("{}", stringify!(record_expr_field_list)))
                    .map(|it| RecordExprFieldList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::RefExpr> for RefExpr {
    type Error = String;
    fn try_from(item: super::nodes::RefExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            amp_token: item.amp_token().is_some(),
            raw_token: item.raw_token().is_some(),
            mut_token: item.mut_token().is_some(),
            const_token: item.const_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ReturnExpr> for ReturnExpr {
    type Error = String;
    fn try_from(item: super::nodes::ReturnExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            return_token: item.return_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::TryExpr> for TryExpr {
    type Error = String;
    fn try_from(item: super::nodes::TryExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            question_mark_token: item.question_mark_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TupleExpr> for TupleExpr {
    type Error = String;
    fn try_from(item: super::nodes::TupleExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            l_paren_token: item.l_paren_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::WhileExpr> for WhileExpr {
    type Error = String;
    fn try_from(item: super::nodes::WhileExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            label: match item.label() {
                Some(it) => Some(Box::new(Label::try_from(it)?)),
                None => None,
            },
            while_token: item.while_token().is_some(),
            invariant_clause: match item.invariant_clause() {
                Some(it) => Some(Box::new(InvariantClause::try_from(it)?)),
                None => None,
            },
            decreases_clause: match item.decreases_clause() {
                Some(it) => Some(Box::new(DecreasesClause::try_from(it)?)),
                None => None,
            },
            loop_body: Box::new(
                item.loop_body()
                    .ok_or(format!("{}", stringify!(loop_body)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::YieldExpr> for YieldExpr {
    type Error = String;
    fn try_from(item: super::nodes::YieldExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            yield_token: item.yield_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::YeetExpr> for YeetExpr {
    type Error = String;
    fn try_from(item: super::nodes::YeetExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            do_token: item.do_token().is_some(),
            yeet_token: item.yeet_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::LetExpr> for LetExpr {
    type Error = String;
    fn try_from(item: super::nodes::LetExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            let_token: item.let_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::UnderscoreExpr> for UnderscoreExpr {
    type Error = String;
    fn try_from(item: super::nodes::UnderscoreExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            underscore_token: item.underscore_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::ViewExpr> for ViewExpr {
    type Error = String;
    fn try_from(item: super::nodes::ViewExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            at_token: item.at_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::AssertExpr> for AssertExpr {
    type Error = String;
    fn try_from(item: super::nodes::AssertExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            assert_token: item.assert_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
            by_token: item.by_token().is_some(),
            name: match item.name() {
                Some(it) => Some(Box::new(Name::try_from(it)?)),
                None => None,
            },
            requires_clause: match item.requires_clause() {
                Some(it) => Some(Box::new(RequiresClause::try_from(it)?)),
                None => None,
            },
            block_expr: match item.block_expr() {
                Some(it) => Some(Box::new(BlockExpr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::AssumeExpr> for AssumeExpr {
    type Error = String;
    fn try_from(item: super::nodes::AssumeExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            assume_token: item.assume_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::AssertForallExpr> for AssertForallExpr {
    type Error = String;
    fn try_from(item: super::nodes::AssertForallExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            assert_token: item.assert_token().is_some(),
            forall_token: item.forall_token().is_some(),
            closure_expr: Box::new(
                item.closure_expr()
                    .ok_or(format!("{}", stringify!(closure_expr)))
                    .map(|it| ClosureExpr::try_from(it))??,
            ),
            implies_token: item.implies_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            by_token: item.by_token().is_some(),
            block_expr: Box::new(
                item.block_expr()
                    .ok_or(format!("{}", stringify!(block_expr)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::StmtList> for StmtList {
    type Error = String;
    fn try_from(item: super::nodes::StmtList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            statements: item
                .statements()
                .into_iter()
                .map(Stmt::try_from)
                .collect::<Result<Vec<Stmt>, String>>()?,
            tail_expr: match item.tail_expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Label> for Label {
    type Error = String;
    fn try_from(item: super::nodes::Label) -> Result<Self, Self::Error> {
        Ok(Self {
            lifetime: Box::new(
                item.lifetime()
                    .ok_or(format!("{}", stringify!(lifetime)))
                    .map(|it| Lifetime::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::RecordExprFieldList> for RecordExprFieldList {
    type Error = String;
    fn try_from(item: super::nodes::RecordExprFieldList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            fields: item
                .fields()
                .into_iter()
                .map(RecordExprField::try_from)
                .collect::<Result<Vec<RecordExprField>, String>>()?,
            dotdot_token: item.dotdot_token().is_some(),
            spread: match item.spread() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::RecordExprField> for RecordExprField {
    type Error = String;
    fn try_from(item: super::nodes::RecordExprField) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            name_ref: match item.name_ref() {
                Some(it) => Some(Box::new(NameRef::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ArgList> for ArgList {
    type Error = String;
    fn try_from(item: super::nodes::ArgList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            args: item
                .args()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::InvariantClause> for InvariantClause {
    type Error = String;
    fn try_from(item: super::nodes::InvariantClause) -> Result<Self, Self::Error> {
        Ok(Self {
            invariant_token: item.invariant_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::MatchArmList> for MatchArmList {
    type Error = String;
    fn try_from(item: super::nodes::MatchArmList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            arms: item
                .arms()
                .into_iter()
                .map(MatchArm::try_from)
                .collect::<Result<Vec<MatchArm>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::MatchArm> for MatchArm {
    type Error = String;
    fn try_from(item: super::nodes::MatchArm) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            guard: match item.guard() {
                Some(it) => Some(Box::new(MatchGuard::try_from(it)?)),
                None => None,
            },
            fat_arrow_token: item.fat_arrow_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            comma_token: item.comma_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::MatchGuard> for MatchGuard {
    type Error = String;
    fn try_from(item: super::nodes::MatchGuard) -> Result<Self, Self::Error> {
        Ok(Self { if_token: item.if_token().is_some() })
    }
}
impl TryFrom<super::nodes::ArrayType> for ArrayType {
    type Error = String;
    fn try_from(item: super::nodes::ArrayType) -> Result<Self, Self::Error> {
        Ok(Self {
            l_brack_token: item.l_brack_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
            semicolon_token: item.semicolon_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            r_brack_token: item.r_brack_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::DynTraitType> for DynTraitType {
    type Error = String;
    fn try_from(item: super::nodes::DynTraitType) -> Result<Self, Self::Error> {
        Ok(Self {
            dyn_token: item.dyn_token().is_some(),
            type_bound_list: Box::new(
                item.type_bound_list()
                    .ok_or(format!("{}", stringify!(type_bound_list)))
                    .map(|it| TypeBoundList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::FnPtrType> for FnPtrType {
    type Error = String;
    fn try_from(item: super::nodes::FnPtrType) -> Result<Self, Self::Error> {
        Ok(Self {
            const_token: item.const_token().is_some(),
            async_token: item.async_token().is_some(),
            unsafe_token: item.unsafe_token().is_some(),
            abi: match item.abi() {
                Some(it) => Some(Box::new(Abi::try_from(it)?)),
                None => None,
            },
            fn_token: item.fn_token().is_some(),
            param_list: match item.param_list() {
                Some(it) => Some(Box::new(ParamList::try_from(it)?)),
                None => None,
            },
            ret_type: match item.ret_type() {
                Some(it) => Some(Box::new(RetType::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::ForType> for ForType {
    type Error = String;
    fn try_from(item: super::nodes::ForType) -> Result<Self, Self::Error> {
        Ok(Self {
            for_token: item.for_token().is_some(),
            generic_param_list: Box::new(
                item.generic_param_list()
                    .ok_or(format!("{}", stringify!(generic_param_list)))
                    .map(|it| GenericParamList::try_from(it))??,
            ),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ImplTraitType> for ImplTraitType {
    type Error = String;
    fn try_from(item: super::nodes::ImplTraitType) -> Result<Self, Self::Error> {
        Ok(Self {
            impl_token: item.impl_token().is_some(),
            type_bound_list: Box::new(
                item.type_bound_list()
                    .ok_or(format!("{}", stringify!(type_bound_list)))
                    .map(|it| TypeBoundList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::InferType> for InferType {
    type Error = String;
    fn try_from(item: super::nodes::InferType) -> Result<Self, Self::Error> {
        Ok(Self { underscore_token: item.underscore_token().is_some() })
    }
}
impl TryFrom<super::nodes::MacroType> for MacroType {
    type Error = String;
    fn try_from(item: super::nodes::MacroType) -> Result<Self, Self::Error> {
        Ok(Self {
            macro_call: Box::new(
                item.macro_call()
                    .ok_or(format!("{}", stringify!(macro_call)))
                    .map(|it| MacroCall::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::NeverType> for NeverType {
    type Error = String;
    fn try_from(item: super::nodes::NeverType) -> Result<Self, Self::Error> {
        Ok(Self { excl_token: item.excl_token().is_some() })
    }
}
impl TryFrom<super::nodes::ParenType> for ParenType {
    type Error = String;
    fn try_from(item: super::nodes::ParenType) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::PtrType> for PtrType {
    type Error = String;
    fn try_from(item: super::nodes::PtrType) -> Result<Self, Self::Error> {
        Ok(Self {
            star_token: item.star_token().is_some(),
            const_token: item.const_token().is_some(),
            mut_token: item.mut_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::RefType> for RefType {
    type Error = String;
    fn try_from(item: super::nodes::RefType) -> Result<Self, Self::Error> {
        Ok(Self {
            amp_token: item.amp_token().is_some(),
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
            mut_token: item.mut_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::SliceType> for SliceType {
    type Error = String;
    fn try_from(item: super::nodes::SliceType) -> Result<Self, Self::Error> {
        Ok(Self {
            l_brack_token: item.l_brack_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
            r_brack_token: item.r_brack_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TupleType> for TupleType {
    type Error = String;
    fn try_from(item: super::nodes::TupleType) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(Type::try_from)
                .collect::<Result<Vec<Type>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TypeBound> for TypeBound {
    type Error = String;
    fn try_from(item: super::nodes::TypeBound) -> Result<Self, Self::Error> {
        Ok(Self {
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
            question_mark_token: item.question_mark_token().is_some(),
            tilde_token: item.tilde_token().is_some(),
            const_token: item.const_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::IdentPat> for IdentPat {
    type Error = String;
    fn try_from(item: super::nodes::IdentPat) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            ref_token: item.ref_token().is_some(),
            mut_token: item.mut_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            at_token: item.at_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::BoxPat> for BoxPat {
    type Error = String;
    fn try_from(item: super::nodes::BoxPat) -> Result<Self, Self::Error> {
        Ok(Self {
            box_token: item.box_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::RestPat> for RestPat {
    type Error = String;
    fn try_from(item: super::nodes::RestPat) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            dotdot_token: item.dotdot_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::LiteralPat> for LiteralPat {
    type Error = String;
    fn try_from(item: super::nodes::LiteralPat) -> Result<Self, Self::Error> {
        Ok(Self {
            minus_token: item.minus_token().is_some(),
            literal: Box::new(
                item.literal()
                    .ok_or(format!("{}", stringify!(literal)))
                    .map(|it| Literal::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::MacroPat> for MacroPat {
    type Error = String;
    fn try_from(item: super::nodes::MacroPat) -> Result<Self, Self::Error> {
        Ok(Self {
            macro_call: Box::new(
                item.macro_call()
                    .ok_or(format!("{}", stringify!(macro_call)))
                    .map(|it| MacroCall::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::OrPat> for OrPat {
    type Error = String;
    fn try_from(item: super::nodes::OrPat) -> Result<Self, Self::Error> {
        Ok(Self {
            pats: item
                .pats()
                .into_iter()
                .map(Pat::try_from)
                .collect::<Result<Vec<Pat>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::ParenPat> for ParenPat {
    type Error = String;
    fn try_from(item: super::nodes::ParenPat) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::PathPat> for PathPat {
    type Error = String;
    fn try_from(item: super::nodes::PathPat) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::WildcardPat> for WildcardPat {
    type Error = String;
    fn try_from(item: super::nodes::WildcardPat) -> Result<Self, Self::Error> {
        Ok(Self { underscore_token: item.underscore_token().is_some() })
    }
}
impl TryFrom<super::nodes::RangePat> for RangePat {
    type Error = String;
    fn try_from(item: super::nodes::RangePat) -> Result<Self, Self::Error> { Ok(Self {}) }
}
impl TryFrom<super::nodes::RecordPat> for RecordPat {
    type Error = String;
    fn try_from(item: super::nodes::RecordPat) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            record_pat_field_list: Box::new(
                item.record_pat_field_list()
                    .ok_or(format!("{}", stringify!(record_pat_field_list)))
                    .map(|it| RecordPatFieldList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::RefPat> for RefPat {
    type Error = String;
    fn try_from(item: super::nodes::RefPat) -> Result<Self, Self::Error> {
        Ok(Self {
            amp_token: item.amp_token().is_some(),
            mut_token: item.mut_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::SlicePat> for SlicePat {
    type Error = String;
    fn try_from(item: super::nodes::SlicePat) -> Result<Self, Self::Error> {
        Ok(Self {
            l_brack_token: item.l_brack_token().is_some(),
            pats: item
                .pats()
                .into_iter()
                .map(Pat::try_from)
                .collect::<Result<Vec<Pat>, String>>()?,
            r_brack_token: item.r_brack_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TuplePat> for TuplePat {
    type Error = String;
    fn try_from(item: super::nodes::TuplePat) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(Pat::try_from)
                .collect::<Result<Vec<Pat>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TupleStructPat> for TupleStructPat {
    type Error = String;
    fn try_from(item: super::nodes::TupleStructPat) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            l_paren_token: item.l_paren_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(Pat::try_from)
                .collect::<Result<Vec<Pat>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::ConstBlockPat> for ConstBlockPat {
    type Error = String;
    fn try_from(item: super::nodes::ConstBlockPat) -> Result<Self, Self::Error> {
        Ok(Self {
            const_token: item.const_token().is_some(),
            block_expr: Box::new(
                item.block_expr()
                    .ok_or(format!("{}", stringify!(block_expr)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::RecordPatFieldList> for RecordPatFieldList {
    type Error = String;
    fn try_from(item: super::nodes::RecordPatFieldList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(RecordPatField::try_from)
                .collect::<Result<Vec<RecordPatField>, String>>()?,
            rest_pat: match item.rest_pat() {
                Some(it) => Some(Box::new(RestPat::try_from(it)?)),
                None => None,
            },
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::RecordPatField> for RecordPatField {
    type Error = String;
    fn try_from(item: super::nodes::RecordPatField) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            name_ref: match item.name_ref() {
                Some(it) => Some(Box::new(NameRef::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::ModeSpecChecked> for ModeSpecChecked {
    type Error = String;
    fn try_from(item: super::nodes::ModeSpecChecked) -> Result<Self, Self::Error> {
        Ok(Self {
            spec_token: item.spec_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            checked_token: item.checked_token().is_some(),
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::SignatureDecreases> for SignatureDecreases {
    type Error = String;
    fn try_from(item: super::nodes::SignatureDecreases) -> Result<Self, Self::Error> {
        Ok(Self {
            decreases_clause: Box::new(
                item.decreases_clause()
                    .ok_or(format!("{}", stringify!(decreases_clause)))
                    .map(|it| DecreasesClause::try_from(it))??,
            ),
            when_token: item.when_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            via_token: item.via_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Prover> for Prover {
    type Error = String;
    fn try_from(item: super::nodes::Prover) -> Result<Self, Self::Error> {
        Ok(Self {
            by_token: item.by_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TriggerAttribute> for TriggerAttribute {
    type Error = String;
    fn try_from(item: super::nodes::TriggerAttribute) -> Result<Self, Self::Error> {
        Ok(Self {
            pound_token: item.pound_token().is_some(),
            excl_token: item.excl_token().is_some(),
            l_brack_token: item.l_brack_token().is_some(),
            trigger_token: item.trigger_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            r_brack_token: item.r_brack_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::GenericArg> for GenericArg {
    type Error = String;
    fn try_from(item: super::nodes::GenericArg) -> Result<Self, Self::Error> {
        match item {
            super::nodes::GenericArg::TypeArg(it) => Ok(Self::TypeArg(Box::new(it.try_into()?))),
            super::nodes::GenericArg::AssocTypeArg(it) => {
                Ok(Self::AssocTypeArg(Box::new(it.try_into()?)))
            }
            super::nodes::GenericArg::LifetimeArg(it) => {
                Ok(Self::LifetimeArg(Box::new(it.try_into()?)))
            }
            super::nodes::GenericArg::ConstArg(it) => Ok(Self::ConstArg(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::Type> for Type {
    type Error = String;
    fn try_from(item: super::nodes::Type) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Type::ArrayType(it) => Ok(Self::ArrayType(Box::new(it.try_into()?))),
            super::nodes::Type::DynTraitType(it) => {
                Ok(Self::DynTraitType(Box::new(it.try_into()?)))
            }
            super::nodes::Type::FnPtrType(it) => Ok(Self::FnPtrType(Box::new(it.try_into()?))),
            super::nodes::Type::ForType(it) => Ok(Self::ForType(Box::new(it.try_into()?))),
            super::nodes::Type::ImplTraitType(it) => {
                Ok(Self::ImplTraitType(Box::new(it.try_into()?)))
            }
            super::nodes::Type::InferType(it) => Ok(Self::InferType(Box::new(it.try_into()?))),
            super::nodes::Type::MacroType(it) => Ok(Self::MacroType(Box::new(it.try_into()?))),
            super::nodes::Type::NeverType(it) => Ok(Self::NeverType(Box::new(it.try_into()?))),
            super::nodes::Type::ParenType(it) => Ok(Self::ParenType(Box::new(it.try_into()?))),
            super::nodes::Type::PathType(it) => Ok(Self::PathType(Box::new(it.try_into()?))),
            super::nodes::Type::PtrType(it) => Ok(Self::PtrType(Box::new(it.try_into()?))),
            super::nodes::Type::RefType(it) => Ok(Self::RefType(Box::new(it.try_into()?))),
            super::nodes::Type::SliceType(it) => Ok(Self::SliceType(Box::new(it.try_into()?))),
            super::nodes::Type::TupleType(it) => Ok(Self::TupleType(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::Expr> for Expr {
    type Error = String;
    fn try_from(item: super::nodes::Expr) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Expr::ArrayExpr(it) => Ok(Self::ArrayExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::AwaitExpr(it) => Ok(Self::AwaitExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::BinExpr(it) => Ok(Self::BinExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::BlockExpr(it) => Ok(Self::BlockExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::BoxExpr(it) => Ok(Self::BoxExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::BreakExpr(it) => Ok(Self::BreakExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::CallExpr(it) => Ok(Self::CallExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::CastExpr(it) => Ok(Self::CastExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::ClosureExpr(it) => Ok(Self::ClosureExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::ContinueExpr(it) => {
                Ok(Self::ContinueExpr(Box::new(it.try_into()?)))
            }
            super::nodes::Expr::FieldExpr(it) => Ok(Self::FieldExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::ForExpr(it) => Ok(Self::ForExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::IfExpr(it) => Ok(Self::IfExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::IndexExpr(it) => Ok(Self::IndexExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::Literal(it) => Ok(Self::Literal(Box::new(it.try_into()?))),
            super::nodes::Expr::LoopExpr(it) => Ok(Self::LoopExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::MacroExpr(it) => Ok(Self::MacroExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::MatchExpr(it) => Ok(Self::MatchExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::MethodCallExpr(it) => {
                Ok(Self::MethodCallExpr(Box::new(it.try_into()?)))
            }
            super::nodes::Expr::ParenExpr(it) => Ok(Self::ParenExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::PathExpr(it) => Ok(Self::PathExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::PrefixExpr(it) => Ok(Self::PrefixExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::RangeExpr(it) => Ok(Self::RangeExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::RecordExpr(it) => Ok(Self::RecordExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::RefExpr(it) => Ok(Self::RefExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::ReturnExpr(it) => Ok(Self::ReturnExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::TryExpr(it) => Ok(Self::TryExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::TupleExpr(it) => Ok(Self::TupleExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::WhileExpr(it) => Ok(Self::WhileExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::YieldExpr(it) => Ok(Self::YieldExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::YeetExpr(it) => Ok(Self::YeetExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::LetExpr(it) => Ok(Self::LetExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::UnderscoreExpr(it) => {
                Ok(Self::UnderscoreExpr(Box::new(it.try_into()?)))
            }
            super::nodes::Expr::ViewExpr(it) => Ok(Self::ViewExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::AssertExpr(it) => Ok(Self::AssertExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::AssumeExpr(it) => Ok(Self::AssumeExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::AssertForallExpr(it) => {
                Ok(Self::AssertForallExpr(Box::new(it.try_into()?)))
            }
        }
    }
}
impl TryFrom<super::nodes::Item> for Item {
    type Error = String;
    fn try_from(item: super::nodes::Item) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Item::Const(it) => Ok(Self::Const(Box::new(it.try_into()?))),
            super::nodes::Item::Enum(it) => Ok(Self::Enum(Box::new(it.try_into()?))),
            super::nodes::Item::ExternBlock(it) => Ok(Self::ExternBlock(Box::new(it.try_into()?))),
            super::nodes::Item::ExternCrate(it) => Ok(Self::ExternCrate(Box::new(it.try_into()?))),
            super::nodes::Item::Fn(it) => Ok(Self::Fn(Box::new(it.try_into()?))),
            super::nodes::Item::Impl(it) => Ok(Self::Impl(Box::new(it.try_into()?))),
            super::nodes::Item::MacroCall(it) => Ok(Self::MacroCall(Box::new(it.try_into()?))),
            super::nodes::Item::MacroRules(it) => Ok(Self::MacroRules(Box::new(it.try_into()?))),
            super::nodes::Item::MacroDef(it) => Ok(Self::MacroDef(Box::new(it.try_into()?))),
            super::nodes::Item::Module(it) => Ok(Self::Module(Box::new(it.try_into()?))),
            super::nodes::Item::Static(it) => Ok(Self::Static(Box::new(it.try_into()?))),
            super::nodes::Item::Struct(it) => Ok(Self::Struct(Box::new(it.try_into()?))),
            super::nodes::Item::Trait(it) => Ok(Self::Trait(Box::new(it.try_into()?))),
            super::nodes::Item::TraitAlias(it) => Ok(Self::TraitAlias(Box::new(it.try_into()?))),
            super::nodes::Item::TypeAlias(it) => Ok(Self::TypeAlias(Box::new(it.try_into()?))),
            super::nodes::Item::Union(it) => Ok(Self::Union(Box::new(it.try_into()?))),
            super::nodes::Item::Use(it) => Ok(Self::Use(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::Stmt> for Stmt {
    type Error = String;
    fn try_from(item: super::nodes::Stmt) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Stmt::ExprStmt(it) => Ok(Self::ExprStmt(Box::new(it.try_into()?))),
            super::nodes::Stmt::Item(it) => Ok(Self::Item(Box::new(it.try_into()?))),
            super::nodes::Stmt::LetStmt(it) => Ok(Self::LetStmt(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::Pat> for Pat {
    type Error = String;
    fn try_from(item: super::nodes::Pat) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Pat::IdentPat(it) => Ok(Self::IdentPat(Box::new(it.try_into()?))),
            super::nodes::Pat::BoxPat(it) => Ok(Self::BoxPat(Box::new(it.try_into()?))),
            super::nodes::Pat::RestPat(it) => Ok(Self::RestPat(Box::new(it.try_into()?))),
            super::nodes::Pat::LiteralPat(it) => Ok(Self::LiteralPat(Box::new(it.try_into()?))),
            super::nodes::Pat::MacroPat(it) => Ok(Self::MacroPat(Box::new(it.try_into()?))),
            super::nodes::Pat::OrPat(it) => Ok(Self::OrPat(Box::new(it.try_into()?))),
            super::nodes::Pat::ParenPat(it) => Ok(Self::ParenPat(Box::new(it.try_into()?))),
            super::nodes::Pat::PathPat(it) => Ok(Self::PathPat(Box::new(it.try_into()?))),
            super::nodes::Pat::WildcardPat(it) => Ok(Self::WildcardPat(Box::new(it.try_into()?))),
            super::nodes::Pat::RangePat(it) => Ok(Self::RangePat(Box::new(it.try_into()?))),
            super::nodes::Pat::RecordPat(it) => Ok(Self::RecordPat(Box::new(it.try_into()?))),
            super::nodes::Pat::RefPat(it) => Ok(Self::RefPat(Box::new(it.try_into()?))),
            super::nodes::Pat::SlicePat(it) => Ok(Self::SlicePat(Box::new(it.try_into()?))),
            super::nodes::Pat::TuplePat(it) => Ok(Self::TuplePat(Box::new(it.try_into()?))),
            super::nodes::Pat::TupleStructPat(it) => {
                Ok(Self::TupleStructPat(Box::new(it.try_into()?)))
            }
            super::nodes::Pat::ConstBlockPat(it) => {
                Ok(Self::ConstBlockPat(Box::new(it.try_into()?)))
            }
        }
    }
}
impl TryFrom<super::nodes::FieldList> for FieldList {
    type Error = String;
    fn try_from(item: super::nodes::FieldList) -> Result<Self, Self::Error> {
        match item {
            super::nodes::FieldList::RecordFieldList(it) => {
                Ok(Self::RecordFieldList(Box::new(it.try_into()?)))
            }
            super::nodes::FieldList::TupleFieldList(it) => {
                Ok(Self::TupleFieldList(Box::new(it.try_into()?)))
            }
        }
    }
}
impl TryFrom<super::nodes::Adt> for Adt {
    type Error = String;
    fn try_from(item: super::nodes::Adt) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Adt::Enum(it) => Ok(Self::Enum(Box::new(it.try_into()?))),
            super::nodes::Adt::Struct(it) => Ok(Self::Struct(Box::new(it.try_into()?))),
            super::nodes::Adt::Union(it) => Ok(Self::Union(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::AssocItem> for AssocItem {
    type Error = String;
    fn try_from(item: super::nodes::AssocItem) -> Result<Self, Self::Error> {
        match item {
            super::nodes::AssocItem::Const(it) => Ok(Self::Const(Box::new(it.try_into()?))),
            super::nodes::AssocItem::Fn(it) => Ok(Self::Fn(Box::new(it.try_into()?))),
            super::nodes::AssocItem::MacroCall(it) => Ok(Self::MacroCall(Box::new(it.try_into()?))),
            super::nodes::AssocItem::TypeAlias(it) => Ok(Self::TypeAlias(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::ExternItem> for ExternItem {
    type Error = String;
    fn try_from(item: super::nodes::ExternItem) -> Result<Self, Self::Error> {
        match item {
            super::nodes::ExternItem::Fn(it) => Ok(Self::Fn(Box::new(it.try_into()?))),
            super::nodes::ExternItem::MacroCall(it) => {
                Ok(Self::MacroCall(Box::new(it.try_into()?)))
            }
            super::nodes::ExternItem::Static(it) => Ok(Self::Static(Box::new(it.try_into()?))),
            super::nodes::ExternItem::TypeAlias(it) => {
                Ok(Self::TypeAlias(Box::new(it.try_into()?)))
            }
        }
    }
}
impl TryFrom<super::nodes::GenericParam> for GenericParam {
    type Error = String;
    fn try_from(item: super::nodes::GenericParam) -> Result<Self, Self::Error> {
        match item {
            super::nodes::GenericParam::ConstParam(it) => {
                Ok(Self::ConstParam(Box::new(it.try_into()?)))
            }
            super::nodes::GenericParam::LifetimeParam(it) => {
                Ok(Self::LifetimeParam(Box::new(it.try_into()?)))
            }
            super::nodes::GenericParam::TypeParam(it) => {
                Ok(Self::TypeParam(Box::new(it.try_into()?)))
            }
        }
    }
}
