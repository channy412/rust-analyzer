//! Generated by `sourcegen_vst`, do not edit by hand.

#![allow(non_snake_case)]
use crate::{
    ast::{self, support, traits::*, vst::*, AstChildren, AstNode},
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
};
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub ident_token: Option<String>,
    pub self_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameRef {
    pub ident_token: Option<String>,
    pub self_token: bool,
    pub super_token: bool,
    pub crate_token: bool,
    pub Self_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Lifetime {
    pub lifetime_ident_token: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Path {
    pub qualifier: Option<Box<Path>>,
    pub coloncolon_token: bool,
    pub segment: Box<PathSegment>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathSegment {
    pub coloncolon_token: bool,
    pub name_ref: Box<NameRef>,
    pub generic_arg_list: Option<Box<GenericArgList>>,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    pub l_angle_token: bool,
    pub path_type: Option<Box<PathType>>,
    pub as_token: bool,
    pub r_angle_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GenericArgList {
    pub coloncolon_token: bool,
    pub l_angle_token: bool,
    pub generic_args: Vec<GenericArg>,
    pub r_angle_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParamList {
    pub l_paren_token: bool,
    pub self_param: Option<Box<SelfParam>>,
    pub comma_token: bool,
    pub params: Vec<Param>,
    pub r_paren_token: bool,
    pub pipe_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RetType {
    pub thin_arrow_token: bool,
    pub tracked_token: bool,
    pub l_paren_token: bool,
    pub pat: Option<Box<Pat>>,
    pub colon_token: bool,
    pub ty: Box<Type>,
    pub r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathType {
    pub path: Box<Path>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeArg {
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssocTypeArg {
    pub name_ref: Box<NameRef>,
    pub generic_arg_list: Option<Box<GenericArgList>>,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    pub colon_token: bool,
    pub type_bound_list: Box<TypeBoundList>,
    pub eq_token: bool,
    pub ty: Box<Type>,
    pub const_arg: Option<Box<ConstArg>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LifetimeArg {
    pub lifetime: Box<Lifetime>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstArg {
    pub expr: Box<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeBoundList {
    pub bounds: Vec<TypeBound>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroCall {
    pub attrs: Vec<Attr>,
    pub path: Box<Path>,
    pub excl_token: bool,
    pub token_tree: Box<TokenTree>,
    pub semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Attr {
    pub pound_token: bool,
    pub excl_token: bool,
    pub l_brack_token: bool,
    pub meta: Box<Meta>,
    pub r_brack_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TokenTree {
    pub l_paren_token: bool,
    pub r_paren_token: bool,
    pub l_curly_token: bool,
    pub r_curly_token: bool,
    pub l_brack_token: bool,
    pub r_brack_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroItems {
    pub items: Vec<Item>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroStmts {
    pub statements: Vec<Stmt>,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub shebang_token: bool,
    pub attrs: Vec<Attr>,
    pub items: Vec<Item>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Const {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub default_token: bool,
    pub const_token: bool,
    pub name: Option<Box<Name>>,
    pub underscore_token: bool,
    pub colon_token: bool,
    pub ty: Box<Type>,
    pub eq_token: bool,
    pub body: Option<Box<Expr>>,
    pub semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Enum {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub enum_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub variant_list: Box<VariantList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternBlock {
    pub attrs: Vec<Attr>,
    pub unsafe_token: bool,
    pub abi: Box<Abi>,
    pub extern_item_list: Box<ExternItemList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternCrate {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub extern_token: bool,
    pub crate_token: bool,
    pub name_ref: Box<NameRef>,
    pub rename: Option<Box<Rename>>,
    pub semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Fn {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub publish: Option<Box<Publish>>,
    pub default_token: bool,
    pub const_token: bool,
    pub async_token: bool,
    pub unsafe_token: bool,
    pub abi: Option<Box<Abi>>,
    pub fn_mode: Option<Box<FnMode>>,
    pub fn_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub requires_clause: Option<Box<RequiresClause>>,
    pub recommends_clause: Option<Box<RecommendsClause>>,
    pub ensures_clause: Option<Box<EnsuresClause>>,
    pub decreases_clause: Option<Box<DecreasesClause>>,
    pub body: Option<Box<BlockExpr>>,
    pub semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Impl {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub default_token: bool,
    pub unsafe_token: bool,
    pub impl_token: bool,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub const_token: bool,
    pub excl_token: bool,
    pub for_token: bool,
    pub where_clause: Option<Box<WhereClause>>,
    pub assoc_item_list: Box<AssocItemList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroRules {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub macro_rules_token: bool,
    pub excl_token: bool,
    pub name: Box<Name>,
    pub token_tree: Box<TokenTree>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroDef {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub macro_token: bool,
    pub name: Box<Name>,
    pub args: Option<Box<TokenTree>>,
    pub body: Box<TokenTree>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Module {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub mod_token: bool,
    pub name: Box<Name>,
    pub item_list: Option<Box<ItemList>>,
    pub semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Static {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub static_token: bool,
    pub mut_token: bool,
    pub name: Box<Name>,
    pub colon_token: bool,
    pub ty: Box<Type>,
    pub eq_token: bool,
    pub body: Option<Box<Expr>>,
    pub semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Struct {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub data_mode: Option<Box<DataMode>>,
    pub struct_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub semicolon_token: bool,
    pub field_list: Option<Box<FieldList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Trait {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub unsafe_token: bool,
    pub auto_token: bool,
    pub trait_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub colon_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub assoc_item_list: Box<AssocItemList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TraitAlias {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub trait_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub eq_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeAlias {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub default_token: bool,
    pub type_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub colon_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub eq_token: bool,
    pub ty: Option<Box<Type>>,
    pub semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Union {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub union_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub record_field_list: Box<RecordFieldList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Use {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub use_token: bool,
    pub use_tree: Box<UseTree>,
    pub semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Visibility {
    pub pub_token: bool,
    pub l_paren_token: bool,
    pub in_token: bool,
    pub path: Option<Box<Path>>,
    pub r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ItemList {
    pub l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub items: Vec<Item>,
    pub r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Rename {
    pub as_token: bool,
    pub name: Option<Box<Name>>,
    pub underscore_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseTree {
    pub path: Option<Box<Path>>,
    pub coloncolon_token: bool,
    pub star_token: bool,
    pub use_tree_list: Option<Box<UseTreeList>>,
    pub rename: Option<Box<Rename>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseTreeList {
    pub l_curly_token: bool,
    pub use_trees: Vec<UseTree>,
    pub r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Publish {
    pub closed_token: bool,
    pub open_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Abi {
    pub extern_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnMode {
    pub spec_token: bool,
    pub proof_token: bool,
    pub exec_token: bool,
    pub mode_spec_checked: Option<Box<ModeSpecChecked>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GenericParamList {
    pub l_angle_token: bool,
    pub generic_params: Vec<GenericParam>,
    pub r_angle_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhereClause {
    pub where_token: bool,
    pub predicates: Vec<WherePred>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RequiresClause {
    pub requires_token: bool,
    pub exprs: Vec<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecommendsClause {
    pub recommends_token: bool,
    pub exprs: Vec<Expr>,
    pub via_token: bool,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnsuresClause {
    pub ensures_token: bool,
    pub exprs: Vec<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DecreasesClause {
    pub decreases_token: bool,
    pub exprs: Vec<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockExpr {
    pub attrs: Vec<Attr>,
    pub label: Option<Box<Label>>,
    pub try_token: bool,
    pub unsafe_token: bool,
    pub async_token: bool,
    pub const_token: bool,
    pub stmt_list: Box<StmtList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelfParam {
    pub attrs: Vec<Attr>,
    pub amp_token: bool,
    pub lifetime: Option<Box<Lifetime>>,
    pub mut_token: bool,
    pub name: Box<Name>,
    pub colon_token: bool,
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Param {
    pub attrs: Vec<Attr>,
    pub tracked_token: bool,
    pub pat: Option<Box<Pat>>,
    pub colon_token: bool,
    pub ty: Option<Box<Type>>,
    pub dotdotdot_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DataMode {
    pub ghost_token: bool,
    pub tracked_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordFieldList {
    pub l_curly_token: bool,
    pub fields: Vec<RecordField>,
    pub r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleFieldList {
    pub l_paren_token: bool,
    pub fields: Vec<TupleField>,
    pub r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordField {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub data_mode: Option<Box<DataMode>>,
    pub name: Box<Name>,
    pub colon_token: bool,
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleField {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariantList {
    pub l_curly_token: bool,
    pub variants: Vec<Variant>,
    pub r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Variant {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub name: Box<Name>,
    pub field_list: Option<Box<FieldList>>,
    pub eq_token: bool,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssocItemList {
    pub l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub assoc_items: Vec<AssocItem>,
    pub r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternItemList {
    pub l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub extern_items: Vec<ExternItem>,
    pub r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstParam {
    pub attrs: Vec<Attr>,
    pub const_token: bool,
    pub name: Box<Name>,
    pub colon_token: bool,
    pub ty: Box<Type>,
    pub eq_token: bool,
    pub default_val: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LifetimeParam {
    pub attrs: Vec<Attr>,
    pub lifetime: Box<Lifetime>,
    pub colon_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParam {
    pub attrs: Vec<Attr>,
    pub name: Box<Name>,
    pub colon_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
    pub eq_token: bool,
    pub default_type: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WherePred {
    pub for_token: bool,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub lifetime: Option<Box<Lifetime>>,
    pub ty: Option<Box<Type>>,
    pub colon_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Meta {
    pub path: Box<Path>,
    pub eq_token: bool,
    pub expr: Option<Box<Expr>>,
    pub token_tree: Option<Box<TokenTree>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub expr: Box<Expr>,
    pub semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetStmt {
    pub attrs: Vec<Attr>,
    pub let_token: bool,
    pub ghost_token: bool,
    pub tracked_token: bool,
    pub pat: Option<Box<Pat>>,
    pub colon_token: bool,
    pub ty: Option<Box<Type>>,
    pub eq_token: bool,
    pub initializer: Box<Expr>,
    pub let_else: Option<Box<LetElse>>,
    pub semicolon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetElse {
    pub else_token: bool,
    pub block_expr: Box<BlockExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayExpr {
    pub attrs: Vec<Attr>,
    pub l_brack_token: bool,
    pub exprs: Vec<Expr>,
    pub expr: Box<Expr>,
    pub semicolon_token: bool,
    pub r_brack_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AwaitExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub dot_token: bool,
    pub await_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BoxExpr {
    pub attrs: Vec<Attr>,
    pub box_token: bool,
    pub expr: Box<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakExpr {
    pub attrs: Vec<Attr>,
    pub break_token: bool,
    pub lifetime: Option<Box<Lifetime>>,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub arg_list: Box<ArgList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CastExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub as_token: bool,
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClosureExpr {
    pub attrs: Vec<Attr>,
    pub for_token: bool,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub const_token: bool,
    pub static_token: bool,
    pub async_token: bool,
    pub move_token: bool,
    pub forall_token: bool,
    pub exists_token: bool,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    pub body: Box<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueExpr {
    pub attrs: Vec<Attr>,
    pub continue_token: bool,
    pub lifetime: Option<Box<Lifetime>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FieldExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub dot_token: bool,
    pub name_ref: Box<NameRef>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForExpr {
    pub attrs: Vec<Attr>,
    pub label: Option<Box<Label>>,
    pub for_token: bool,
    pub pat: Option<Box<Pat>>,
    pub in_token: bool,
    pub loop_body: Box<BlockExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr {
    pub attrs: Vec<Attr>,
    pub l_brack_token: bool,
    pub r_brack_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LoopExpr {
    pub attrs: Vec<Attr>,
    pub label: Option<Box<Label>>,
    pub loop_token: bool,
    pub loop_body: Box<BlockExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroExpr {
    pub macro_call: Box<MacroCall>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchExpr {
    pub attrs: Vec<Attr>,
    pub match_token: bool,
    pub expr: Box<Expr>,
    pub match_arm_list: Box<MatchArmList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodCallExpr {
    pub attrs: Vec<Attr>,
    pub receiver: Box<Expr>,
    pub dot_token: bool,
    pub name_ref: Box<NameRef>,
    pub generic_arg_list: Option<Box<GenericArgList>>,
    pub arg_list: Box<ArgList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr {
    pub attrs: Vec<Attr>,
    pub l_paren_token: bool,
    pub expr: Box<Expr>,
    pub r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathExpr {
    pub attrs: Vec<Attr>,
    pub path: Box<Path>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExpr {
    pub attrs: Vec<Attr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordExpr {
    pub path: Box<Path>,
    pub record_expr_field_list: Box<RecordExprFieldList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefExpr {
    pub attrs: Vec<Attr>,
    pub amp_token: bool,
    pub raw_token: bool,
    pub mut_token: bool,
    pub const_token: bool,
    pub expr: Box<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnExpr {
    pub attrs: Vec<Attr>,
    pub return_token: bool,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub question_mark_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleExpr {
    pub attrs: Vec<Attr>,
    pub l_paren_token: bool,
    pub fields: Vec<Expr>,
    pub r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr {
    pub attrs: Vec<Attr>,
    pub label: Option<Box<Label>>,
    pub while_token: bool,
    pub invariant_clause: Option<Box<InvariantClause>>,
    pub decreases_clause: Option<Box<DecreasesClause>>,
    pub loop_body: Box<BlockExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct YieldExpr {
    pub attrs: Vec<Attr>,
    pub yield_token: bool,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct YeetExpr {
    pub attrs: Vec<Attr>,
    pub do_token: bool,
    pub yeet_token: bool,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetExpr {
    pub attrs: Vec<Attr>,
    pub let_token: bool,
    pub pat: Option<Box<Pat>>,
    pub eq_token: bool,
    pub expr: Box<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnderscoreExpr {
    pub attrs: Vec<Attr>,
    pub underscore_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ViewExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub at_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssertExpr {
    pub attrs: Vec<Attr>,
    pub assert_token: bool,
    pub l_paren_token: bool,
    pub expr: Box<Expr>,
    pub r_paren_token: bool,
    pub by_token: bool,
    pub name: Option<Box<Name>>,
    pub requires_clause: Option<Box<RequiresClause>>,
    pub block_expr: Option<Box<BlockExpr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssumeExpr {
    pub attrs: Vec<Attr>,
    pub assume_token: bool,
    pub l_paren_token: bool,
    pub expr: Box<Expr>,
    pub r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssertForallExpr {
    pub attrs: Vec<Attr>,
    pub assert_token: bool,
    pub forall_token: bool,
    pub closure_expr: Box<ClosureExpr>,
    pub implies_token: bool,
    pub expr: Option<Box<Expr>>,
    pub by_token: bool,
    pub block_expr: Box<BlockExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StmtList {
    pub l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub statements: Vec<Stmt>,
    pub tail_expr: Option<Box<Expr>>,
    pub r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Label {
    pub lifetime: Box<Lifetime>,
    pub colon_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordExprFieldList {
    pub l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub fields: Vec<RecordExprField>,
    pub dotdot_token: bool,
    pub spread: Option<Box<Expr>>,
    pub r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordExprField {
    pub attrs: Vec<Attr>,
    pub name_ref: Option<Box<NameRef>>,
    pub colon_token: bool,
    pub expr: Box<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgList {
    pub l_paren_token: bool,
    pub args: Vec<Expr>,
    pub r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InvariantClause {
    pub invariant_token: bool,
    pub exprs: Vec<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArmList {
    pub l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub arms: Vec<MatchArm>,
    pub r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArm {
    pub attrs: Vec<Attr>,
    pub pat: Option<Box<Pat>>,
    pub guard: Option<Box<MatchGuard>>,
    pub fat_arrow_token: bool,
    pub expr: Box<Expr>,
    pub comma_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchGuard {
    pub if_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayType {
    pub l_brack_token: bool,
    pub ty: Box<Type>,
    pub semicolon_token: bool,
    pub expr: Box<Expr>,
    pub r_brack_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DynTraitType {
    pub dyn_token: bool,
    pub type_bound_list: Box<TypeBoundList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnPtrType {
    pub const_token: bool,
    pub async_token: bool,
    pub unsafe_token: bool,
    pub abi: Option<Box<Abi>>,
    pub fn_token: bool,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForType {
    pub for_token: bool,
    pub generic_param_list: Box<GenericParamList>,
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImplTraitType {
    pub impl_token: bool,
    pub type_bound_list: Box<TypeBoundList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InferType {
    pub underscore_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroType {
    pub macro_call: Box<MacroCall>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NeverType {
    pub excl_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenType {
    pub l_paren_token: bool,
    pub ty: Box<Type>,
    pub r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PtrType {
    pub star_token: bool,
    pub const_token: bool,
    pub mut_token: bool,
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefType {
    pub amp_token: bool,
    pub lifetime: Option<Box<Lifetime>>,
    pub mut_token: bool,
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SliceType {
    pub l_brack_token: bool,
    pub ty: Box<Type>,
    pub r_brack_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleType {
    pub l_paren_token: bool,
    pub fields: Vec<Type>,
    pub r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeBound {
    pub lifetime: Option<Box<Lifetime>>,
    pub question_mark_token: bool,
    pub tilde_token: bool,
    pub const_token: bool,
    pub ty: Box<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentPat {
    pub attrs: Vec<Attr>,
    pub ref_token: bool,
    pub mut_token: bool,
    pub name: Box<Name>,
    pub at_token: bool,
    pub pat: Option<Box<Pat>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BoxPat {
    pub box_token: bool,
    pub pat: Option<Box<Pat>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RestPat {
    pub attrs: Vec<Attr>,
    pub dotdot_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralPat {
    pub minus_token: bool,
    pub literal: Box<Literal>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroPat {
    pub macro_call: Box<MacroCall>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OrPat {
    pub pats: Vec<Pat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenPat {
    pub l_paren_token: bool,
    pub pat: Option<Box<Pat>>,
    pub r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathPat {
    pub path: Box<Path>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WildcardPat {
    pub underscore_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangePat {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordPat {
    pub path: Box<Path>,
    pub record_pat_field_list: Box<RecordPatFieldList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefPat {
    pub amp_token: bool,
    pub mut_token: bool,
    pub pat: Option<Box<Pat>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SlicePat {
    pub l_brack_token: bool,
    pub pats: Vec<Pat>,
    pub r_brack_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TuplePat {
    pub l_paren_token: bool,
    pub fields: Vec<Pat>,
    pub r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleStructPat {
    pub path: Box<Path>,
    pub l_paren_token: bool,
    pub fields: Vec<Pat>,
    pub r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstBlockPat {
    pub const_token: bool,
    pub block_expr: Box<BlockExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordPatFieldList {
    pub l_curly_token: bool,
    pub fields: Vec<RecordPatField>,
    pub rest_pat: Option<Box<RestPat>>,
    pub r_curly_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordPatField {
    pub attrs: Vec<Attr>,
    pub name_ref: Option<Box<NameRef>>,
    pub colon_token: bool,
    pub pat: Option<Box<Pat>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModeSpecChecked {
    pub spec_token: bool,
    pub l_paren_token: bool,
    pub checked_token: bool,
    pub r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SignatureDecreases {
    pub decreases_clause: Box<DecreasesClause>,
    pub when_token: bool,
    pub expr: Option<Box<Expr>>,
    pub via_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Prover {
    pub by_token: bool,
    pub l_paren_token: bool,
    pub name: Box<Name>,
    pub r_paren_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TriggerAttribute {
    pub pound_token: bool,
    pub excl_token: bool,
    pub l_brack_token: bool,
    pub trigger_token: bool,
    pub exprs: Vec<Expr>,
    pub r_brack_token: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum GenericArg {
    TypeArg(Box<TypeArg>),
    AssocTypeArg(Box<AssocTypeArg>),
    LifetimeArg(Box<LifetimeArg>),
    ConstArg(Box<ConstArg>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    ArrayType(Box<ArrayType>),
    DynTraitType(Box<DynTraitType>),
    FnPtrType(Box<FnPtrType>),
    ForType(Box<ForType>),
    ImplTraitType(Box<ImplTraitType>),
    InferType(Box<InferType>),
    MacroType(Box<MacroType>),
    NeverType(Box<NeverType>),
    ParenType(Box<ParenType>),
    PathType(Box<PathType>),
    PtrType(Box<PtrType>),
    RefType(Box<RefType>),
    SliceType(Box<SliceType>),
    TupleType(Box<TupleType>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    ArrayExpr(Box<ArrayExpr>),
    AwaitExpr(Box<AwaitExpr>),
    BinExpr(Box<BinExpr>),
    BlockExpr(Box<BlockExpr>),
    BoxExpr(Box<BoxExpr>),
    BreakExpr(Box<BreakExpr>),
    CallExpr(Box<CallExpr>),
    CastExpr(Box<CastExpr>),
    ClosureExpr(Box<ClosureExpr>),
    ContinueExpr(Box<ContinueExpr>),
    FieldExpr(Box<FieldExpr>),
    ForExpr(Box<ForExpr>),
    IfExpr(Box<IfExpr>),
    IndexExpr(Box<IndexExpr>),
    Literal(Box<Literal>),
    LoopExpr(Box<LoopExpr>),
    MacroExpr(Box<MacroExpr>),
    MatchExpr(Box<MatchExpr>),
    MethodCallExpr(Box<MethodCallExpr>),
    ParenExpr(Box<ParenExpr>),
    PathExpr(Box<PathExpr>),
    PrefixExpr(Box<PrefixExpr>),
    RangeExpr(Box<RangeExpr>),
    RecordExpr(Box<RecordExpr>),
    RefExpr(Box<RefExpr>),
    ReturnExpr(Box<ReturnExpr>),
    TryExpr(Box<TryExpr>),
    TupleExpr(Box<TupleExpr>),
    WhileExpr(Box<WhileExpr>),
    YieldExpr(Box<YieldExpr>),
    YeetExpr(Box<YeetExpr>),
    LetExpr(Box<LetExpr>),
    UnderscoreExpr(Box<UnderscoreExpr>),
    ViewExpr(Box<ViewExpr>),
    AssertExpr(Box<AssertExpr>),
    AssumeExpr(Box<AssumeExpr>),
    AssertForallExpr(Box<AssertForallExpr>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Item {
    Const(Box<Const>),
    Enum(Box<Enum>),
    ExternBlock(Box<ExternBlock>),
    ExternCrate(Box<ExternCrate>),
    Fn(Box<Fn>),
    Impl(Box<Impl>),
    MacroCall(Box<MacroCall>),
    MacroRules(Box<MacroRules>),
    MacroDef(Box<MacroDef>),
    Module(Box<Module>),
    Static(Box<Static>),
    Struct(Box<Struct>),
    Trait(Box<Trait>),
    TraitAlias(Box<TraitAlias>),
    TypeAlias(Box<TypeAlias>),
    Union(Box<Union>),
    Use(Box<Use>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    ExprStmt(Box<ExprStmt>),
    Item(Box<Item>),
    LetStmt(Box<LetStmt>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Pat {
    IdentPat(Box<IdentPat>),
    BoxPat(Box<BoxPat>),
    RestPat(Box<RestPat>),
    LiteralPat(Box<LiteralPat>),
    MacroPat(Box<MacroPat>),
    OrPat(Box<OrPat>),
    ParenPat(Box<ParenPat>),
    PathPat(Box<PathPat>),
    WildcardPat(Box<WildcardPat>),
    RangePat(Box<RangePat>),
    RecordPat(Box<RecordPat>),
    RefPat(Box<RefPat>),
    SlicePat(Box<SlicePat>),
    TuplePat(Box<TuplePat>),
    TupleStructPat(Box<TupleStructPat>),
    ConstBlockPat(Box<ConstBlockPat>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FieldList {
    RecordFieldList(Box<RecordFieldList>),
    TupleFieldList(Box<TupleFieldList>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Adt {
    Enum(Box<Enum>),
    Struct(Box<Struct>),
    Union(Box<Union>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AssocItem {
    Const(Box<Const>),
    Fn(Box<Fn>),
    MacroCall(Box<MacroCall>),
    TypeAlias(Box<TypeAlias>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ExternItem {
    Fn(Box<Fn>),
    MacroCall(Box<MacroCall>),
    Static(Box<Static>),
    TypeAlias(Box<TypeAlias>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum GenericParam {
    ConstParam(Box<ConstParam>),
    LifetimeParam(Box<LifetimeParam>),
    TypeParam(Box<TypeParam>),
}
impl TryFrom<super::nodes::Name> for Name {
    type Error = String;
    fn try_from(item: super::nodes::Name) -> Result<Self, Self::Error> {
        Ok(Self {
            ident_token: item.ident_token().map(|it| it.text().to_string()),
            self_token: item.self_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::NameRef> for NameRef {
    type Error = String;
    fn try_from(item: super::nodes::NameRef) -> Result<Self, Self::Error> {
        Ok(Self {
            ident_token: item.ident_token().map(|it| it.text().to_string()),
            self_token: item.self_token().is_some(),
            super_token: item.super_token().is_some(),
            crate_token: item.crate_token().is_some(),
            Self_token: item.Self_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Lifetime> for Lifetime {
    type Error = String;
    fn try_from(item: super::nodes::Lifetime) -> Result<Self, Self::Error> {
        Ok(Self {
            lifetime_ident_token: item.lifetime_ident_token().map(|it| it.text().to_string()),
        })
    }
}
impl TryFrom<super::nodes::Path> for Path {
    type Error = String;
    fn try_from(item: super::nodes::Path) -> Result<Self, Self::Error> {
        Ok(Self {
            qualifier: match item.qualifier() {
                Some(it) => Some(Box::new(Path::try_from(it)?)),
                None => None,
            },
            coloncolon_token: item.coloncolon_token().is_some(),
            segment: Box::new(
                item.segment()
                    .ok_or(format!("{}", stringify!(segment)))
                    .map(|it| PathSegment::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::PathSegment> for PathSegment {
    type Error = String;
    fn try_from(item: super::nodes::PathSegment) -> Result<Self, Self::Error> {
        Ok(Self {
            coloncolon_token: item.coloncolon_token().is_some(),
            name_ref: Box::new(
                item.name_ref()
                    .ok_or(format!("{}", stringify!(name_ref)))
                    .map(|it| NameRef::try_from(it))??,
            ),
            generic_arg_list: match item.generic_arg_list() {
                Some(it) => Some(Box::new(GenericArgList::try_from(it)?)),
                None => None,
            },
            param_list: match item.param_list() {
                Some(it) => Some(Box::new(ParamList::try_from(it)?)),
                None => None,
            },
            ret_type: match item.ret_type() {
                Some(it) => Some(Box::new(RetType::try_from(it)?)),
                None => None,
            },
            l_angle_token: item.l_angle_token().is_some(),
            path_type: match item.path_type() {
                Some(it) => Some(Box::new(PathType::try_from(it)?)),
                None => None,
            },
            as_token: item.as_token().is_some(),
            r_angle_token: item.r_angle_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::GenericArgList> for GenericArgList {
    type Error = String;
    fn try_from(item: super::nodes::GenericArgList) -> Result<Self, Self::Error> {
        Ok(Self {
            coloncolon_token: item.coloncolon_token().is_some(),
            l_angle_token: item.l_angle_token().is_some(),
            generic_args: item
                .generic_args()
                .into_iter()
                .map(GenericArg::try_from)
                .collect::<Result<Vec<GenericArg>, String>>()?,
            r_angle_token: item.r_angle_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::ParamList> for ParamList {
    type Error = String;
    fn try_from(item: super::nodes::ParamList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            self_param: match item.self_param() {
                Some(it) => Some(Box::new(SelfParam::try_from(it)?)),
                None => None,
            },
            comma_token: item.comma_token().is_some(),
            params: item
                .params()
                .into_iter()
                .map(Param::try_from)
                .collect::<Result<Vec<Param>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
            pipe_token: item.pipe_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::RetType> for RetType {
    type Error = String;
    fn try_from(item: super::nodes::RetType) -> Result<Self, Self::Error> {
        Ok(Self {
            thin_arrow_token: item.thin_arrow_token().is_some(),
            tracked_token: item.tracked_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::PathType> for PathType {
    type Error = String;
    fn try_from(item: super::nodes::PathType) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::TypeArg> for TypeArg {
    type Error = String;
    fn try_from(item: super::nodes::TypeArg) -> Result<Self, Self::Error> {
        Ok(Self {
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::AssocTypeArg> for AssocTypeArg {
    type Error = String;
    fn try_from(item: super::nodes::AssocTypeArg) -> Result<Self, Self::Error> {
        Ok(Self {
            name_ref: Box::new(
                item.name_ref()
                    .ok_or(format!("{}", stringify!(name_ref)))
                    .map(|it| NameRef::try_from(it))??,
            ),
            generic_arg_list: match item.generic_arg_list() {
                Some(it) => Some(Box::new(GenericArgList::try_from(it)?)),
                None => None,
            },
            param_list: match item.param_list() {
                Some(it) => Some(Box::new(ParamList::try_from(it)?)),
                None => None,
            },
            ret_type: match item.ret_type() {
                Some(it) => Some(Box::new(RetType::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            type_bound_list: Box::new(
                item.type_bound_list()
                    .ok_or(format!("{}", stringify!(type_bound_list)))
                    .map(|it| TypeBoundList::try_from(it))??,
            ),
            eq_token: item.eq_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
            const_arg: match item.const_arg() {
                Some(it) => Some(Box::new(ConstArg::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::LifetimeArg> for LifetimeArg {
    type Error = String;
    fn try_from(item: super::nodes::LifetimeArg) -> Result<Self, Self::Error> {
        Ok(Self {
            lifetime: Box::new(
                item.lifetime()
                    .ok_or(format!("{}", stringify!(lifetime)))
                    .map(|it| Lifetime::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ConstArg> for ConstArg {
    type Error = String;
    fn try_from(item: super::nodes::ConstArg) -> Result<Self, Self::Error> {
        Ok(Self {
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::TypeBoundList> for TypeBoundList {
    type Error = String;
    fn try_from(item: super::nodes::TypeBoundList) -> Result<Self, Self::Error> {
        Ok(Self {
            bounds: item
                .bounds()
                .into_iter()
                .map(TypeBound::try_from)
                .collect::<Result<Vec<TypeBound>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::MacroCall> for MacroCall {
    type Error = String;
    fn try_from(item: super::nodes::MacroCall) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            excl_token: item.excl_token().is_some(),
            token_tree: Box::new(
                item.token_tree()
                    .ok_or(format!("{}", stringify!(token_tree)))
                    .map(|it| TokenTree::try_from(it))??,
            ),
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Attr> for Attr {
    type Error = String;
    fn try_from(item: super::nodes::Attr) -> Result<Self, Self::Error> {
        Ok(Self {
            pound_token: item.pound_token().is_some(),
            excl_token: item.excl_token().is_some(),
            l_brack_token: item.l_brack_token().is_some(),
            meta: Box::new(
                item.meta()
                    .ok_or(format!("{}", stringify!(meta)))
                    .map(|it| Meta::try_from(it))??,
            ),
            r_brack_token: item.r_brack_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TokenTree> for TokenTree {
    type Error = String;
    fn try_from(item: super::nodes::TokenTree) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            r_paren_token: item.r_paren_token().is_some(),
            l_curly_token: item.l_curly_token().is_some(),
            r_curly_token: item.r_curly_token().is_some(),
            l_brack_token: item.l_brack_token().is_some(),
            r_brack_token: item.r_brack_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::MacroItems> for MacroItems {
    type Error = String;
    fn try_from(item: super::nodes::MacroItems) -> Result<Self, Self::Error> {
        Ok(Self {
            items: item
                .items()
                .into_iter()
                .map(Item::try_from)
                .collect::<Result<Vec<Item>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::MacroStmts> for MacroStmts {
    type Error = String;
    fn try_from(item: super::nodes::MacroStmts) -> Result<Self, Self::Error> {
        Ok(Self {
            statements: item
                .statements()
                .into_iter()
                .map(Stmt::try_from)
                .collect::<Result<Vec<Stmt>, String>>()?,
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::SourceFile> for SourceFile {
    type Error = String;
    fn try_from(item: super::nodes::SourceFile) -> Result<Self, Self::Error> {
        Ok(Self {
            shebang_token: item.shebang_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            items: item
                .items()
                .into_iter()
                .map(Item::try_from)
                .collect::<Result<Vec<Item>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::Const> for Const {
    type Error = String;
    fn try_from(item: super::nodes::Const) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            default_token: item.default_token().is_some(),
            const_token: item.const_token().is_some(),
            name: match item.name() {
                Some(it) => Some(Box::new(Name::try_from(it)?)),
                None => None,
            },
            underscore_token: item.underscore_token().is_some(),
            colon_token: item.colon_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
            eq_token: item.eq_token().is_some(),
            body: match item.body() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Enum> for Enum {
    type Error = String;
    fn try_from(item: super::nodes::Enum) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            enum_token: item.enum_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            variant_list: Box::new(
                item.variant_list()
                    .ok_or(format!("{}", stringify!(variant_list)))
                    .map(|it| VariantList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ExternBlock> for ExternBlock {
    type Error = String;
    fn try_from(item: super::nodes::ExternBlock) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            unsafe_token: item.unsafe_token().is_some(),
            abi: Box::new(
                item.abi().ok_or(format!("{}", stringify!(abi))).map(|it| Abi::try_from(it))??,
            ),
            extern_item_list: Box::new(
                item.extern_item_list()
                    .ok_or(format!("{}", stringify!(extern_item_list)))
                    .map(|it| ExternItemList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ExternCrate> for ExternCrate {
    type Error = String;
    fn try_from(item: super::nodes::ExternCrate) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            extern_token: item.extern_token().is_some(),
            crate_token: item.crate_token().is_some(),
            name_ref: Box::new(
                item.name_ref()
                    .ok_or(format!("{}", stringify!(name_ref)))
                    .map(|it| NameRef::try_from(it))??,
            ),
            rename: match item.rename() {
                Some(it) => Some(Box::new(Rename::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Fn> for Fn {
    type Error = String;
    fn try_from(item: super::nodes::Fn) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            publish: match item.publish() {
                Some(it) => Some(Box::new(Publish::try_from(it)?)),
                None => None,
            },
            default_token: item.default_token().is_some(),
            const_token: item.const_token().is_some(),
            async_token: item.async_token().is_some(),
            unsafe_token: item.unsafe_token().is_some(),
            abi: match item.abi() {
                Some(it) => Some(Box::new(Abi::try_from(it)?)),
                None => None,
            },
            fn_mode: match item.fn_mode() {
                Some(it) => Some(Box::new(FnMode::try_from(it)?)),
                None => None,
            },
            fn_token: item.fn_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            param_list: match item.param_list() {
                Some(it) => Some(Box::new(ParamList::try_from(it)?)),
                None => None,
            },
            ret_type: match item.ret_type() {
                Some(it) => Some(Box::new(RetType::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            requires_clause: match item.requires_clause() {
                Some(it) => Some(Box::new(RequiresClause::try_from(it)?)),
                None => None,
            },
            recommends_clause: match item.recommends_clause() {
                Some(it) => Some(Box::new(RecommendsClause::try_from(it)?)),
                None => None,
            },
            ensures_clause: match item.ensures_clause() {
                Some(it) => Some(Box::new(EnsuresClause::try_from(it)?)),
                None => None,
            },
            decreases_clause: match item.decreases_clause() {
                Some(it) => Some(Box::new(DecreasesClause::try_from(it)?)),
                None => None,
            },
            body: match item.body() {
                Some(it) => Some(Box::new(BlockExpr::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Impl> for Impl {
    type Error = String;
    fn try_from(item: super::nodes::Impl) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            default_token: item.default_token().is_some(),
            unsafe_token: item.unsafe_token().is_some(),
            impl_token: item.impl_token().is_some(),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            const_token: item.const_token().is_some(),
            excl_token: item.excl_token().is_some(),
            for_token: item.for_token().is_some(),
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            assoc_item_list: Box::new(
                item.assoc_item_list()
                    .ok_or(format!("{}", stringify!(assoc_item_list)))
                    .map(|it| AssocItemList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::MacroRules> for MacroRules {
    type Error = String;
    fn try_from(item: super::nodes::MacroRules) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            macro_rules_token: item.macro_rules_token().is_some(),
            excl_token: item.excl_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            token_tree: Box::new(
                item.token_tree()
                    .ok_or(format!("{}", stringify!(token_tree)))
                    .map(|it| TokenTree::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::MacroDef> for MacroDef {
    type Error = String;
    fn try_from(item: super::nodes::MacroDef) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            macro_token: item.macro_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            args: match item.args() {
                Some(it) => Some(Box::new(TokenTree::try_from(it)?)),
                None => None,
            },
            body: Box::new(
                item.body()
                    .ok_or(format!("{}", stringify!(body)))
                    .map(|it| TokenTree::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::Module> for Module {
    type Error = String;
    fn try_from(item: super::nodes::Module) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            mod_token: item.mod_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            item_list: match item.item_list() {
                Some(it) => Some(Box::new(ItemList::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Static> for Static {
    type Error = String;
    fn try_from(item: super::nodes::Static) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            static_token: item.static_token().is_some(),
            mut_token: item.mut_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
            eq_token: item.eq_token().is_some(),
            body: match item.body() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Struct> for Struct {
    type Error = String;
    fn try_from(item: super::nodes::Struct) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            data_mode: match item.data_mode() {
                Some(it) => Some(Box::new(DataMode::try_from(it)?)),
                None => None,
            },
            struct_token: item.struct_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
            field_list: match item.field_list() {
                Some(it) => Some(Box::new(FieldList::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::Trait> for Trait {
    type Error = String;
    fn try_from(item: super::nodes::Trait) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            unsafe_token: item.unsafe_token().is_some(),
            auto_token: item.auto_token().is_some(),
            trait_token: item.trait_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            assoc_item_list: Box::new(
                item.assoc_item_list()
                    .ok_or(format!("{}", stringify!(assoc_item_list)))
                    .map(|it| AssocItemList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::TraitAlias> for TraitAlias {
    type Error = String;
    fn try_from(item: super::nodes::TraitAlias) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            trait_token: item.trait_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TypeAlias> for TypeAlias {
    type Error = String;
    fn try_from(item: super::nodes::TypeAlias) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            default_token: item.default_token().is_some(),
            type_token: item.type_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Union> for Union {
    type Error = String;
    fn try_from(item: super::nodes::Union) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            union_token: item.union_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            record_field_list: Box::new(
                item.record_field_list()
                    .ok_or(format!("{}", stringify!(record_field_list)))
                    .map(|it| RecordFieldList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::Use> for Use {
    type Error = String;
    fn try_from(item: super::nodes::Use) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            use_token: item.use_token().is_some(),
            use_tree: Box::new(
                item.use_tree()
                    .ok_or(format!("{}", stringify!(use_tree)))
                    .map(|it| UseTree::try_from(it))??,
            ),
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Visibility> for Visibility {
    type Error = String;
    fn try_from(item: super::nodes::Visibility) -> Result<Self, Self::Error> {
        Ok(Self {
            pub_token: item.pub_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            in_token: item.in_token().is_some(),
            path: match item.path() {
                Some(it) => Some(Box::new(Path::try_from(it)?)),
                None => None,
            },
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::ItemList> for ItemList {
    type Error = String;
    fn try_from(item: super::nodes::ItemList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            items: item
                .items()
                .into_iter()
                .map(Item::try_from)
                .collect::<Result<Vec<Item>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Rename> for Rename {
    type Error = String;
    fn try_from(item: super::nodes::Rename) -> Result<Self, Self::Error> {
        Ok(Self {
            as_token: item.as_token().is_some(),
            name: match item.name() {
                Some(it) => Some(Box::new(Name::try_from(it)?)),
                None => None,
            },
            underscore_token: item.underscore_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::UseTree> for UseTree {
    type Error = String;
    fn try_from(item: super::nodes::UseTree) -> Result<Self, Self::Error> {
        Ok(Self {
            path: match item.path() {
                Some(it) => Some(Box::new(Path::try_from(it)?)),
                None => None,
            },
            coloncolon_token: item.coloncolon_token().is_some(),
            star_token: item.star_token().is_some(),
            use_tree_list: match item.use_tree_list() {
                Some(it) => Some(Box::new(UseTreeList::try_from(it)?)),
                None => None,
            },
            rename: match item.rename() {
                Some(it) => Some(Box::new(Rename::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::UseTreeList> for UseTreeList {
    type Error = String;
    fn try_from(item: super::nodes::UseTreeList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            use_trees: item
                .use_trees()
                .into_iter()
                .map(UseTree::try_from)
                .collect::<Result<Vec<UseTree>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Publish> for Publish {
    type Error = String;
    fn try_from(item: super::nodes::Publish) -> Result<Self, Self::Error> {
        Ok(Self {
            closed_token: item.closed_token().is_some(),
            open_token: item.open_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Abi> for Abi {
    type Error = String;
    fn try_from(item: super::nodes::Abi) -> Result<Self, Self::Error> {
        Ok(Self { extern_token: item.extern_token().is_some() })
    }
}
impl TryFrom<super::nodes::FnMode> for FnMode {
    type Error = String;
    fn try_from(item: super::nodes::FnMode) -> Result<Self, Self::Error> {
        Ok(Self {
            spec_token: item.spec_token().is_some(),
            proof_token: item.proof_token().is_some(),
            exec_token: item.exec_token().is_some(),
            mode_spec_checked: match item.mode_spec_checked() {
                Some(it) => Some(Box::new(ModeSpecChecked::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::GenericParamList> for GenericParamList {
    type Error = String;
    fn try_from(item: super::nodes::GenericParamList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_angle_token: item.l_angle_token().is_some(),
            generic_params: item
                .generic_params()
                .into_iter()
                .map(GenericParam::try_from)
                .collect::<Result<Vec<GenericParam>, String>>()?,
            r_angle_token: item.r_angle_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::WhereClause> for WhereClause {
    type Error = String;
    fn try_from(item: super::nodes::WhereClause) -> Result<Self, Self::Error> {
        Ok(Self {
            where_token: item.where_token().is_some(),
            predicates: item
                .predicates()
                .into_iter()
                .map(WherePred::try_from)
                .collect::<Result<Vec<WherePred>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::RequiresClause> for RequiresClause {
    type Error = String;
    fn try_from(item: super::nodes::RequiresClause) -> Result<Self, Self::Error> {
        Ok(Self {
            requires_token: item.requires_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::RecommendsClause> for RecommendsClause {
    type Error = String;
    fn try_from(item: super::nodes::RecommendsClause) -> Result<Self, Self::Error> {
        Ok(Self {
            recommends_token: item.recommends_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            via_token: item.via_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::EnsuresClause> for EnsuresClause {
    type Error = String;
    fn try_from(item: super::nodes::EnsuresClause) -> Result<Self, Self::Error> {
        Ok(Self {
            ensures_token: item.ensures_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::DecreasesClause> for DecreasesClause {
    type Error = String;
    fn try_from(item: super::nodes::DecreasesClause) -> Result<Self, Self::Error> {
        Ok(Self {
            decreases_token: item.decreases_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::BlockExpr> for BlockExpr {
    type Error = String;
    fn try_from(item: super::nodes::BlockExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            label: match item.label() {
                Some(it) => Some(Box::new(Label::try_from(it)?)),
                None => None,
            },
            try_token: item.try_token().is_some(),
            unsafe_token: item.unsafe_token().is_some(),
            async_token: item.async_token().is_some(),
            const_token: item.const_token().is_some(),
            stmt_list: Box::new(
                item.stmt_list()
                    .ok_or(format!("{}", stringify!(stmt_list)))
                    .map(|it| StmtList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::SelfParam> for SelfParam {
    type Error = String;
    fn try_from(item: super::nodes::SelfParam) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            amp_token: item.amp_token().is_some(),
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
            mut_token: item.mut_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::Param> for Param {
    type Error = String;
    fn try_from(item: super::nodes::Param) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            tracked_token: item.tracked_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            dotdotdot_token: item.dotdotdot_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::DataMode> for DataMode {
    type Error = String;
    fn try_from(item: super::nodes::DataMode) -> Result<Self, Self::Error> {
        Ok(Self {
            ghost_token: item.ghost_token().is_some(),
            tracked_token: item.tracked_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::RecordFieldList> for RecordFieldList {
    type Error = String;
    fn try_from(item: super::nodes::RecordFieldList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(RecordField::try_from)
                .collect::<Result<Vec<RecordField>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TupleFieldList> for TupleFieldList {
    type Error = String;
    fn try_from(item: super::nodes::TupleFieldList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(TupleField::try_from)
                .collect::<Result<Vec<TupleField>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::RecordField> for RecordField {
    type Error = String;
    fn try_from(item: super::nodes::RecordField) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            data_mode: match item.data_mode() {
                Some(it) => Some(Box::new(DataMode::try_from(it)?)),
                None => None,
            },
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::TupleField> for TupleField {
    type Error = String;
    fn try_from(item: super::nodes::TupleField) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::VariantList> for VariantList {
    type Error = String;
    fn try_from(item: super::nodes::VariantList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            variants: item
                .variants()
                .into_iter()
                .map(Variant::try_from)
                .collect::<Result<Vec<Variant>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Variant> for Variant {
    type Error = String;
    fn try_from(item: super::nodes::Variant) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            field_list: match item.field_list() {
                Some(it) => Some(Box::new(FieldList::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::AssocItemList> for AssocItemList {
    type Error = String;
    fn try_from(item: super::nodes::AssocItemList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            assoc_items: item
                .assoc_items()
                .into_iter()
                .map(AssocItem::try_from)
                .collect::<Result<Vec<AssocItem>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::ExternItemList> for ExternItemList {
    type Error = String;
    fn try_from(item: super::nodes::ExternItemList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            extern_items: item
                .extern_items()
                .into_iter()
                .map(ExternItem::try_from)
                .collect::<Result<Vec<ExternItem>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::ConstParam> for ConstParam {
    type Error = String;
    fn try_from(item: super::nodes::ConstParam) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            const_token: item.const_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
            eq_token: item.eq_token().is_some(),
            default_val: match item.default_val() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::LifetimeParam> for LifetimeParam {
    type Error = String;
    fn try_from(item: super::nodes::LifetimeParam) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            lifetime: Box::new(
                item.lifetime()
                    .ok_or(format!("{}", stringify!(lifetime)))
                    .map(|it| Lifetime::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::TypeParam> for TypeParam {
    type Error = String;
    fn try_from(item: super::nodes::TypeParam) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            default_type: match item.default_type() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::WherePred> for WherePred {
    type Error = String;
    fn try_from(item: super::nodes::WherePred) -> Result<Self, Self::Error> {
        Ok(Self {
            for_token: item.for_token().is_some(),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::Meta> for Meta {
    type Error = String;
    fn try_from(item: super::nodes::Meta) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            eq_token: item.eq_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            token_tree: match item.token_tree() {
                Some(it) => Some(Box::new(TokenTree::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::ExprStmt> for ExprStmt {
    type Error = String;
    fn try_from(item: super::nodes::ExprStmt) -> Result<Self, Self::Error> {
        Ok(Self {
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::LetStmt> for LetStmt {
    type Error = String;
    fn try_from(item: super::nodes::LetStmt) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            let_token: item.let_token().is_some(),
            ghost_token: item.ghost_token().is_some(),
            tracked_token: item.tracked_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            initializer: Box::new(
                item.initializer()
                    .ok_or(format!("{}", stringify!(initializer)))
                    .map(|it| Expr::try_from(it))??,
            ),
            let_else: match item.let_else() {
                Some(it) => Some(Box::new(LetElse::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::LetElse> for LetElse {
    type Error = String;
    fn try_from(item: super::nodes::LetElse) -> Result<Self, Self::Error> {
        Ok(Self {
            else_token: item.else_token().is_some(),
            block_expr: Box::new(
                item.block_expr()
                    .ok_or(format!("{}", stringify!(block_expr)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ArrayExpr> for ArrayExpr {
    type Error = String;
    fn try_from(item: super::nodes::ArrayExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            l_brack_token: item.l_brack_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            semicolon_token: item.semicolon_token().is_some(),
            r_brack_token: item.r_brack_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::AwaitExpr> for AwaitExpr {
    type Error = String;
    fn try_from(item: super::nodes::AwaitExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            dot_token: item.dot_token().is_some(),
            await_token: item.await_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::BoxExpr> for BoxExpr {
    type Error = String;
    fn try_from(item: super::nodes::BoxExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            box_token: item.box_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::BreakExpr> for BreakExpr {
    type Error = String;
    fn try_from(item: super::nodes::BreakExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            break_token: item.break_token().is_some(),
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::CallExpr> for CallExpr {
    type Error = String;
    fn try_from(item: super::nodes::CallExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            arg_list: Box::new(
                item.arg_list()
                    .ok_or(format!("{}", stringify!(arg_list)))
                    .map(|it| ArgList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::CastExpr> for CastExpr {
    type Error = String;
    fn try_from(item: super::nodes::CastExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            as_token: item.as_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ClosureExpr> for ClosureExpr {
    type Error = String;
    fn try_from(item: super::nodes::ClosureExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            for_token: item.for_token().is_some(),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            const_token: item.const_token().is_some(),
            static_token: item.static_token().is_some(),
            async_token: item.async_token().is_some(),
            move_token: item.move_token().is_some(),
            forall_token: item.forall_token().is_some(),
            exists_token: item.exists_token().is_some(),
            param_list: match item.param_list() {
                Some(it) => Some(Box::new(ParamList::try_from(it)?)),
                None => None,
            },
            ret_type: match item.ret_type() {
                Some(it) => Some(Box::new(RetType::try_from(it)?)),
                None => None,
            },
            body: Box::new(
                item.body()
                    .ok_or(format!("{}", stringify!(body)))
                    .map(|it| Expr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ContinueExpr> for ContinueExpr {
    type Error = String;
    fn try_from(item: super::nodes::ContinueExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            continue_token: item.continue_token().is_some(),
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::FieldExpr> for FieldExpr {
    type Error = String;
    fn try_from(item: super::nodes::FieldExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            dot_token: item.dot_token().is_some(),
            name_ref: Box::new(
                item.name_ref()
                    .ok_or(format!("{}", stringify!(name_ref)))
                    .map(|it| NameRef::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ForExpr> for ForExpr {
    type Error = String;
    fn try_from(item: super::nodes::ForExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            label: match item.label() {
                Some(it) => Some(Box::new(Label::try_from(it)?)),
                None => None,
            },
            for_token: item.for_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            in_token: item.in_token().is_some(),
            loop_body: Box::new(
                item.loop_body()
                    .ok_or(format!("{}", stringify!(loop_body)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::IndexExpr> for IndexExpr {
    type Error = String;
    fn try_from(item: super::nodes::IndexExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            l_brack_token: item.l_brack_token().is_some(),
            r_brack_token: item.r_brack_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::LoopExpr> for LoopExpr {
    type Error = String;
    fn try_from(item: super::nodes::LoopExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            label: match item.label() {
                Some(it) => Some(Box::new(Label::try_from(it)?)),
                None => None,
            },
            loop_token: item.loop_token().is_some(),
            loop_body: Box::new(
                item.loop_body()
                    .ok_or(format!("{}", stringify!(loop_body)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::MacroExpr> for MacroExpr {
    type Error = String;
    fn try_from(item: super::nodes::MacroExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            macro_call: Box::new(
                item.macro_call()
                    .ok_or(format!("{}", stringify!(macro_call)))
                    .map(|it| MacroCall::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::MatchExpr> for MatchExpr {
    type Error = String;
    fn try_from(item: super::nodes::MatchExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            match_token: item.match_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            match_arm_list: Box::new(
                item.match_arm_list()
                    .ok_or(format!("{}", stringify!(match_arm_list)))
                    .map(|it| MatchArmList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::MethodCallExpr> for MethodCallExpr {
    type Error = String;
    fn try_from(item: super::nodes::MethodCallExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            receiver: Box::new(
                item.receiver()
                    .ok_or(format!("{}", stringify!(receiver)))
                    .map(|it| Expr::try_from(it))??,
            ),
            dot_token: item.dot_token().is_some(),
            name_ref: Box::new(
                item.name_ref()
                    .ok_or(format!("{}", stringify!(name_ref)))
                    .map(|it| NameRef::try_from(it))??,
            ),
            generic_arg_list: match item.generic_arg_list() {
                Some(it) => Some(Box::new(GenericArgList::try_from(it)?)),
                None => None,
            },
            arg_list: Box::new(
                item.arg_list()
                    .ok_or(format!("{}", stringify!(arg_list)))
                    .map(|it| ArgList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ParenExpr> for ParenExpr {
    type Error = String;
    fn try_from(item: super::nodes::ParenExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            l_paren_token: item.l_paren_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::PathExpr> for PathExpr {
    type Error = String;
    fn try_from(item: super::nodes::PathExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::PrefixExpr> for PrefixExpr {
    type Error = String;
    fn try_from(item: super::nodes::PrefixExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::RangeExpr> for RangeExpr {
    type Error = String;
    fn try_from(item: super::nodes::RangeExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::RecordExpr> for RecordExpr {
    type Error = String;
    fn try_from(item: super::nodes::RecordExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            record_expr_field_list: Box::new(
                item.record_expr_field_list()
                    .ok_or(format!("{}", stringify!(record_expr_field_list)))
                    .map(|it| RecordExprFieldList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::RefExpr> for RefExpr {
    type Error = String;
    fn try_from(item: super::nodes::RefExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            amp_token: item.amp_token().is_some(),
            raw_token: item.raw_token().is_some(),
            mut_token: item.mut_token().is_some(),
            const_token: item.const_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ReturnExpr> for ReturnExpr {
    type Error = String;
    fn try_from(item: super::nodes::ReturnExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            return_token: item.return_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::TryExpr> for TryExpr {
    type Error = String;
    fn try_from(item: super::nodes::TryExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            question_mark_token: item.question_mark_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TupleExpr> for TupleExpr {
    type Error = String;
    fn try_from(item: super::nodes::TupleExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            l_paren_token: item.l_paren_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::WhileExpr> for WhileExpr {
    type Error = String;
    fn try_from(item: super::nodes::WhileExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            label: match item.label() {
                Some(it) => Some(Box::new(Label::try_from(it)?)),
                None => None,
            },
            while_token: item.while_token().is_some(),
            invariant_clause: match item.invariant_clause() {
                Some(it) => Some(Box::new(InvariantClause::try_from(it)?)),
                None => None,
            },
            decreases_clause: match item.decreases_clause() {
                Some(it) => Some(Box::new(DecreasesClause::try_from(it)?)),
                None => None,
            },
            loop_body: Box::new(
                item.loop_body()
                    .ok_or(format!("{}", stringify!(loop_body)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::YieldExpr> for YieldExpr {
    type Error = String;
    fn try_from(item: super::nodes::YieldExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            yield_token: item.yield_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::YeetExpr> for YeetExpr {
    type Error = String;
    fn try_from(item: super::nodes::YeetExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            do_token: item.do_token().is_some(),
            yeet_token: item.yeet_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::LetExpr> for LetExpr {
    type Error = String;
    fn try_from(item: super::nodes::LetExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            let_token: item.let_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::UnderscoreExpr> for UnderscoreExpr {
    type Error = String;
    fn try_from(item: super::nodes::UnderscoreExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            underscore_token: item.underscore_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::ViewExpr> for ViewExpr {
    type Error = String;
    fn try_from(item: super::nodes::ViewExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            at_token: item.at_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::AssertExpr> for AssertExpr {
    type Error = String;
    fn try_from(item: super::nodes::AssertExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            assert_token: item.assert_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
            by_token: item.by_token().is_some(),
            name: match item.name() {
                Some(it) => Some(Box::new(Name::try_from(it)?)),
                None => None,
            },
            requires_clause: match item.requires_clause() {
                Some(it) => Some(Box::new(RequiresClause::try_from(it)?)),
                None => None,
            },
            block_expr: match item.block_expr() {
                Some(it) => Some(Box::new(BlockExpr::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::AssumeExpr> for AssumeExpr {
    type Error = String;
    fn try_from(item: super::nodes::AssumeExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            assume_token: item.assume_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::AssertForallExpr> for AssertForallExpr {
    type Error = String;
    fn try_from(item: super::nodes::AssertForallExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            assert_token: item.assert_token().is_some(),
            forall_token: item.forall_token().is_some(),
            closure_expr: Box::new(
                item.closure_expr()
                    .ok_or(format!("{}", stringify!(closure_expr)))
                    .map(|it| ClosureExpr::try_from(it))??,
            ),
            implies_token: item.implies_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            by_token: item.by_token().is_some(),
            block_expr: Box::new(
                item.block_expr()
                    .ok_or(format!("{}", stringify!(block_expr)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::StmtList> for StmtList {
    type Error = String;
    fn try_from(item: super::nodes::StmtList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            statements: item
                .statements()
                .into_iter()
                .map(Stmt::try_from)
                .collect::<Result<Vec<Stmt>, String>>()?,
            tail_expr: match item.tail_expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Label> for Label {
    type Error = String;
    fn try_from(item: super::nodes::Label) -> Result<Self, Self::Error> {
        Ok(Self {
            lifetime: Box::new(
                item.lifetime()
                    .ok_or(format!("{}", stringify!(lifetime)))
                    .map(|it| Lifetime::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::RecordExprFieldList> for RecordExprFieldList {
    type Error = String;
    fn try_from(item: super::nodes::RecordExprFieldList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            fields: item
                .fields()
                .into_iter()
                .map(RecordExprField::try_from)
                .collect::<Result<Vec<RecordExprField>, String>>()?,
            dotdot_token: item.dotdot_token().is_some(),
            spread: match item.spread() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::RecordExprField> for RecordExprField {
    type Error = String;
    fn try_from(item: super::nodes::RecordExprField) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            name_ref: match item.name_ref() {
                Some(it) => Some(Box::new(NameRef::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ArgList> for ArgList {
    type Error = String;
    fn try_from(item: super::nodes::ArgList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            args: item
                .args()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::InvariantClause> for InvariantClause {
    type Error = String;
    fn try_from(item: super::nodes::InvariantClause) -> Result<Self, Self::Error> {
        Ok(Self {
            invariant_token: item.invariant_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::MatchArmList> for MatchArmList {
    type Error = String;
    fn try_from(item: super::nodes::MatchArmList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            arms: item
                .arms()
                .into_iter()
                .map(MatchArm::try_from)
                .collect::<Result<Vec<MatchArm>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::MatchArm> for MatchArm {
    type Error = String;
    fn try_from(item: super::nodes::MatchArm) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            guard: match item.guard() {
                Some(it) => Some(Box::new(MatchGuard::try_from(it)?)),
                None => None,
            },
            fat_arrow_token: item.fat_arrow_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            comma_token: item.comma_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::MatchGuard> for MatchGuard {
    type Error = String;
    fn try_from(item: super::nodes::MatchGuard) -> Result<Self, Self::Error> {
        Ok(Self { if_token: item.if_token().is_some() })
    }
}
impl TryFrom<super::nodes::ArrayType> for ArrayType {
    type Error = String;
    fn try_from(item: super::nodes::ArrayType) -> Result<Self, Self::Error> {
        Ok(Self {
            l_brack_token: item.l_brack_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
            semicolon_token: item.semicolon_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            r_brack_token: item.r_brack_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::DynTraitType> for DynTraitType {
    type Error = String;
    fn try_from(item: super::nodes::DynTraitType) -> Result<Self, Self::Error> {
        Ok(Self {
            dyn_token: item.dyn_token().is_some(),
            type_bound_list: Box::new(
                item.type_bound_list()
                    .ok_or(format!("{}", stringify!(type_bound_list)))
                    .map(|it| TypeBoundList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::FnPtrType> for FnPtrType {
    type Error = String;
    fn try_from(item: super::nodes::FnPtrType) -> Result<Self, Self::Error> {
        Ok(Self {
            const_token: item.const_token().is_some(),
            async_token: item.async_token().is_some(),
            unsafe_token: item.unsafe_token().is_some(),
            abi: match item.abi() {
                Some(it) => Some(Box::new(Abi::try_from(it)?)),
                None => None,
            },
            fn_token: item.fn_token().is_some(),
            param_list: match item.param_list() {
                Some(it) => Some(Box::new(ParamList::try_from(it)?)),
                None => None,
            },
            ret_type: match item.ret_type() {
                Some(it) => Some(Box::new(RetType::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::ForType> for ForType {
    type Error = String;
    fn try_from(item: super::nodes::ForType) -> Result<Self, Self::Error> {
        Ok(Self {
            for_token: item.for_token().is_some(),
            generic_param_list: Box::new(
                item.generic_param_list()
                    .ok_or(format!("{}", stringify!(generic_param_list)))
                    .map(|it| GenericParamList::try_from(it))??,
            ),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::ImplTraitType> for ImplTraitType {
    type Error = String;
    fn try_from(item: super::nodes::ImplTraitType) -> Result<Self, Self::Error> {
        Ok(Self {
            impl_token: item.impl_token().is_some(),
            type_bound_list: Box::new(
                item.type_bound_list()
                    .ok_or(format!("{}", stringify!(type_bound_list)))
                    .map(|it| TypeBoundList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::InferType> for InferType {
    type Error = String;
    fn try_from(item: super::nodes::InferType) -> Result<Self, Self::Error> {
        Ok(Self { underscore_token: item.underscore_token().is_some() })
    }
}
impl TryFrom<super::nodes::MacroType> for MacroType {
    type Error = String;
    fn try_from(item: super::nodes::MacroType) -> Result<Self, Self::Error> {
        Ok(Self {
            macro_call: Box::new(
                item.macro_call()
                    .ok_or(format!("{}", stringify!(macro_call)))
                    .map(|it| MacroCall::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::NeverType> for NeverType {
    type Error = String;
    fn try_from(item: super::nodes::NeverType) -> Result<Self, Self::Error> {
        Ok(Self { excl_token: item.excl_token().is_some() })
    }
}
impl TryFrom<super::nodes::ParenType> for ParenType {
    type Error = String;
    fn try_from(item: super::nodes::ParenType) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::PtrType> for PtrType {
    type Error = String;
    fn try_from(item: super::nodes::PtrType) -> Result<Self, Self::Error> {
        Ok(Self {
            star_token: item.star_token().is_some(),
            const_token: item.const_token().is_some(),
            mut_token: item.mut_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::RefType> for RefType {
    type Error = String;
    fn try_from(item: super::nodes::RefType) -> Result<Self, Self::Error> {
        Ok(Self {
            amp_token: item.amp_token().is_some(),
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
            mut_token: item.mut_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::SliceType> for SliceType {
    type Error = String;
    fn try_from(item: super::nodes::SliceType) -> Result<Self, Self::Error> {
        Ok(Self {
            l_brack_token: item.l_brack_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
            r_brack_token: item.r_brack_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TupleType> for TupleType {
    type Error = String;
    fn try_from(item: super::nodes::TupleType) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(Type::try_from)
                .collect::<Result<Vec<Type>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TypeBound> for TypeBound {
    type Error = String;
    fn try_from(item: super::nodes::TypeBound) -> Result<Self, Self::Error> {
        Ok(Self {
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
            question_mark_token: item.question_mark_token().is_some(),
            tilde_token: item.tilde_token().is_some(),
            const_token: item.const_token().is_some(),
            ty: Box::new(
                item.ty().ok_or(format!("{}", stringify!(ty))).map(|it| Type::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::IdentPat> for IdentPat {
    type Error = String;
    fn try_from(item: super::nodes::IdentPat) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            ref_token: item.ref_token().is_some(),
            mut_token: item.mut_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            at_token: item.at_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::BoxPat> for BoxPat {
    type Error = String;
    fn try_from(item: super::nodes::BoxPat) -> Result<Self, Self::Error> {
        Ok(Self {
            box_token: item.box_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::RestPat> for RestPat {
    type Error = String;
    fn try_from(item: super::nodes::RestPat) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            dotdot_token: item.dotdot_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::LiteralPat> for LiteralPat {
    type Error = String;
    fn try_from(item: super::nodes::LiteralPat) -> Result<Self, Self::Error> {
        Ok(Self {
            minus_token: item.minus_token().is_some(),
            literal: Box::new(
                item.literal()
                    .ok_or(format!("{}", stringify!(literal)))
                    .map(|it| Literal::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::MacroPat> for MacroPat {
    type Error = String;
    fn try_from(item: super::nodes::MacroPat) -> Result<Self, Self::Error> {
        Ok(Self {
            macro_call: Box::new(
                item.macro_call()
                    .ok_or(format!("{}", stringify!(macro_call)))
                    .map(|it| MacroCall::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::OrPat> for OrPat {
    type Error = String;
    fn try_from(item: super::nodes::OrPat) -> Result<Self, Self::Error> {
        Ok(Self {
            pats: item
                .pats()
                .into_iter()
                .map(Pat::try_from)
                .collect::<Result<Vec<Pat>, String>>()?,
        })
    }
}
impl TryFrom<super::nodes::ParenPat> for ParenPat {
    type Error = String;
    fn try_from(item: super::nodes::ParenPat) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::PathPat> for PathPat {
    type Error = String;
    fn try_from(item: super::nodes::PathPat) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::WildcardPat> for WildcardPat {
    type Error = String;
    fn try_from(item: super::nodes::WildcardPat) -> Result<Self, Self::Error> {
        Ok(Self { underscore_token: item.underscore_token().is_some() })
    }
}
impl TryFrom<super::nodes::RangePat> for RangePat {
    type Error = String;
    fn try_from(item: super::nodes::RangePat) -> Result<Self, Self::Error> { Ok(Self {}) }
}
impl TryFrom<super::nodes::RecordPat> for RecordPat {
    type Error = String;
    fn try_from(item: super::nodes::RecordPat) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            record_pat_field_list: Box::new(
                item.record_pat_field_list()
                    .ok_or(format!("{}", stringify!(record_pat_field_list)))
                    .map(|it| RecordPatFieldList::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::RefPat> for RefPat {
    type Error = String;
    fn try_from(item: super::nodes::RefPat) -> Result<Self, Self::Error> {
        Ok(Self {
            amp_token: item.amp_token().is_some(),
            mut_token: item.mut_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::SlicePat> for SlicePat {
    type Error = String;
    fn try_from(item: super::nodes::SlicePat) -> Result<Self, Self::Error> {
        Ok(Self {
            l_brack_token: item.l_brack_token().is_some(),
            pats: item
                .pats()
                .into_iter()
                .map(Pat::try_from)
                .collect::<Result<Vec<Pat>, String>>()?,
            r_brack_token: item.r_brack_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TuplePat> for TuplePat {
    type Error = String;
    fn try_from(item: super::nodes::TuplePat) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(Pat::try_from)
                .collect::<Result<Vec<Pat>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TupleStructPat> for TupleStructPat {
    type Error = String;
    fn try_from(item: super::nodes::TupleStructPat) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            l_paren_token: item.l_paren_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(Pat::try_from)
                .collect::<Result<Vec<Pat>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::ConstBlockPat> for ConstBlockPat {
    type Error = String;
    fn try_from(item: super::nodes::ConstBlockPat) -> Result<Self, Self::Error> {
        Ok(Self {
            const_token: item.const_token().is_some(),
            block_expr: Box::new(
                item.block_expr()
                    .ok_or(format!("{}", stringify!(block_expr)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
        })
    }
}
impl TryFrom<super::nodes::RecordPatFieldList> for RecordPatFieldList {
    type Error = String;
    fn try_from(item: super::nodes::RecordPatFieldList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(RecordPatField::try_from)
                .collect::<Result<Vec<RecordPatField>, String>>()?,
            rest_pat: match item.rest_pat() {
                Some(it) => Some(Box::new(RestPat::try_from(it)?)),
                None => None,
            },
            r_curly_token: item.r_curly_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::RecordPatField> for RecordPatField {
    type Error = String;
    fn try_from(item: super::nodes::RecordPatField) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            name_ref: match item.name_ref() {
                Some(it) => Some(Box::new(NameRef::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
        })
    }
}
impl TryFrom<super::nodes::ModeSpecChecked> for ModeSpecChecked {
    type Error = String;
    fn try_from(item: super::nodes::ModeSpecChecked) -> Result<Self, Self::Error> {
        Ok(Self {
            spec_token: item.spec_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            checked_token: item.checked_token().is_some(),
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::SignatureDecreases> for SignatureDecreases {
    type Error = String;
    fn try_from(item: super::nodes::SignatureDecreases) -> Result<Self, Self::Error> {
        Ok(Self {
            decreases_clause: Box::new(
                item.decreases_clause()
                    .ok_or(format!("{}", stringify!(decreases_clause)))
                    .map(|it| DecreasesClause::try_from(it))??,
            ),
            when_token: item.when_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            via_token: item.via_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::Prover> for Prover {
    type Error = String;
    fn try_from(item: super::nodes::Prover) -> Result<Self, Self::Error> {
        Ok(Self {
            by_token: item.by_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::TriggerAttribute> for TriggerAttribute {
    type Error = String;
    fn try_from(item: super::nodes::TriggerAttribute) -> Result<Self, Self::Error> {
        Ok(Self {
            pound_token: item.pound_token().is_some(),
            excl_token: item.excl_token().is_some(),
            l_brack_token: item.l_brack_token().is_some(),
            trigger_token: item.trigger_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            r_brack_token: item.r_brack_token().is_some(),
        })
    }
}
impl TryFrom<super::nodes::GenericArg> for GenericArg {
    type Error = String;
    fn try_from(item: super::nodes::GenericArg) -> Result<Self, Self::Error> {
        match item {
            super::nodes::GenericArg::TypeArg(it) => Ok(Self::TypeArg(Box::new(it.try_into()?))),
            super::nodes::GenericArg::AssocTypeArg(it) => {
                Ok(Self::AssocTypeArg(Box::new(it.try_into()?)))
            }
            super::nodes::GenericArg::LifetimeArg(it) => {
                Ok(Self::LifetimeArg(Box::new(it.try_into()?)))
            }
            super::nodes::GenericArg::ConstArg(it) => Ok(Self::ConstArg(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::Type> for Type {
    type Error = String;
    fn try_from(item: super::nodes::Type) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Type::ArrayType(it) => Ok(Self::ArrayType(Box::new(it.try_into()?))),
            super::nodes::Type::DynTraitType(it) => {
                Ok(Self::DynTraitType(Box::new(it.try_into()?)))
            }
            super::nodes::Type::FnPtrType(it) => Ok(Self::FnPtrType(Box::new(it.try_into()?))),
            super::nodes::Type::ForType(it) => Ok(Self::ForType(Box::new(it.try_into()?))),
            super::nodes::Type::ImplTraitType(it) => {
                Ok(Self::ImplTraitType(Box::new(it.try_into()?)))
            }
            super::nodes::Type::InferType(it) => Ok(Self::InferType(Box::new(it.try_into()?))),
            super::nodes::Type::MacroType(it) => Ok(Self::MacroType(Box::new(it.try_into()?))),
            super::nodes::Type::NeverType(it) => Ok(Self::NeverType(Box::new(it.try_into()?))),
            super::nodes::Type::ParenType(it) => Ok(Self::ParenType(Box::new(it.try_into()?))),
            super::nodes::Type::PathType(it) => Ok(Self::PathType(Box::new(it.try_into()?))),
            super::nodes::Type::PtrType(it) => Ok(Self::PtrType(Box::new(it.try_into()?))),
            super::nodes::Type::RefType(it) => Ok(Self::RefType(Box::new(it.try_into()?))),
            super::nodes::Type::SliceType(it) => Ok(Self::SliceType(Box::new(it.try_into()?))),
            super::nodes::Type::TupleType(it) => Ok(Self::TupleType(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::Expr> for Expr {
    type Error = String;
    fn try_from(item: super::nodes::Expr) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Expr::ArrayExpr(it) => Ok(Self::ArrayExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::AwaitExpr(it) => Ok(Self::AwaitExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::BinExpr(it) => Ok(Self::BinExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::BlockExpr(it) => Ok(Self::BlockExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::BoxExpr(it) => Ok(Self::BoxExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::BreakExpr(it) => Ok(Self::BreakExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::CallExpr(it) => Ok(Self::CallExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::CastExpr(it) => Ok(Self::CastExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::ClosureExpr(it) => Ok(Self::ClosureExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::ContinueExpr(it) => {
                Ok(Self::ContinueExpr(Box::new(it.try_into()?)))
            }
            super::nodes::Expr::FieldExpr(it) => Ok(Self::FieldExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::ForExpr(it) => Ok(Self::ForExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::IfExpr(it) => Ok(Self::IfExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::IndexExpr(it) => Ok(Self::IndexExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::Literal(it) => Ok(Self::Literal(Box::new(it.try_into()?))),
            super::nodes::Expr::LoopExpr(it) => Ok(Self::LoopExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::MacroExpr(it) => Ok(Self::MacroExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::MatchExpr(it) => Ok(Self::MatchExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::MethodCallExpr(it) => {
                Ok(Self::MethodCallExpr(Box::new(it.try_into()?)))
            }
            super::nodes::Expr::ParenExpr(it) => Ok(Self::ParenExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::PathExpr(it) => Ok(Self::PathExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::PrefixExpr(it) => Ok(Self::PrefixExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::RangeExpr(it) => Ok(Self::RangeExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::RecordExpr(it) => Ok(Self::RecordExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::RefExpr(it) => Ok(Self::RefExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::ReturnExpr(it) => Ok(Self::ReturnExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::TryExpr(it) => Ok(Self::TryExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::TupleExpr(it) => Ok(Self::TupleExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::WhileExpr(it) => Ok(Self::WhileExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::YieldExpr(it) => Ok(Self::YieldExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::YeetExpr(it) => Ok(Self::YeetExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::LetExpr(it) => Ok(Self::LetExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::UnderscoreExpr(it) => {
                Ok(Self::UnderscoreExpr(Box::new(it.try_into()?)))
            }
            super::nodes::Expr::ViewExpr(it) => Ok(Self::ViewExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::AssertExpr(it) => Ok(Self::AssertExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::AssumeExpr(it) => Ok(Self::AssumeExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::AssertForallExpr(it) => {
                Ok(Self::AssertForallExpr(Box::new(it.try_into()?)))
            }
        }
    }
}
impl TryFrom<super::nodes::Item> for Item {
    type Error = String;
    fn try_from(item: super::nodes::Item) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Item::Const(it) => Ok(Self::Const(Box::new(it.try_into()?))),
            super::nodes::Item::Enum(it) => Ok(Self::Enum(Box::new(it.try_into()?))),
            super::nodes::Item::ExternBlock(it) => Ok(Self::ExternBlock(Box::new(it.try_into()?))),
            super::nodes::Item::ExternCrate(it) => Ok(Self::ExternCrate(Box::new(it.try_into()?))),
            super::nodes::Item::Fn(it) => Ok(Self::Fn(Box::new(it.try_into()?))),
            super::nodes::Item::Impl(it) => Ok(Self::Impl(Box::new(it.try_into()?))),
            super::nodes::Item::MacroCall(it) => Ok(Self::MacroCall(Box::new(it.try_into()?))),
            super::nodes::Item::MacroRules(it) => Ok(Self::MacroRules(Box::new(it.try_into()?))),
            super::nodes::Item::MacroDef(it) => Ok(Self::MacroDef(Box::new(it.try_into()?))),
            super::nodes::Item::Module(it) => Ok(Self::Module(Box::new(it.try_into()?))),
            super::nodes::Item::Static(it) => Ok(Self::Static(Box::new(it.try_into()?))),
            super::nodes::Item::Struct(it) => Ok(Self::Struct(Box::new(it.try_into()?))),
            super::nodes::Item::Trait(it) => Ok(Self::Trait(Box::new(it.try_into()?))),
            super::nodes::Item::TraitAlias(it) => Ok(Self::TraitAlias(Box::new(it.try_into()?))),
            super::nodes::Item::TypeAlias(it) => Ok(Self::TypeAlias(Box::new(it.try_into()?))),
            super::nodes::Item::Union(it) => Ok(Self::Union(Box::new(it.try_into()?))),
            super::nodes::Item::Use(it) => Ok(Self::Use(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::Stmt> for Stmt {
    type Error = String;
    fn try_from(item: super::nodes::Stmt) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Stmt::ExprStmt(it) => Ok(Self::ExprStmt(Box::new(it.try_into()?))),
            super::nodes::Stmt::Item(it) => Ok(Self::Item(Box::new(it.try_into()?))),
            super::nodes::Stmt::LetStmt(it) => Ok(Self::LetStmt(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::Pat> for Pat {
    type Error = String;
    fn try_from(item: super::nodes::Pat) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Pat::IdentPat(it) => Ok(Self::IdentPat(Box::new(it.try_into()?))),
            super::nodes::Pat::BoxPat(it) => Ok(Self::BoxPat(Box::new(it.try_into()?))),
            super::nodes::Pat::RestPat(it) => Ok(Self::RestPat(Box::new(it.try_into()?))),
            super::nodes::Pat::LiteralPat(it) => Ok(Self::LiteralPat(Box::new(it.try_into()?))),
            super::nodes::Pat::MacroPat(it) => Ok(Self::MacroPat(Box::new(it.try_into()?))),
            super::nodes::Pat::OrPat(it) => Ok(Self::OrPat(Box::new(it.try_into()?))),
            super::nodes::Pat::ParenPat(it) => Ok(Self::ParenPat(Box::new(it.try_into()?))),
            super::nodes::Pat::PathPat(it) => Ok(Self::PathPat(Box::new(it.try_into()?))),
            super::nodes::Pat::WildcardPat(it) => Ok(Self::WildcardPat(Box::new(it.try_into()?))),
            super::nodes::Pat::RangePat(it) => Ok(Self::RangePat(Box::new(it.try_into()?))),
            super::nodes::Pat::RecordPat(it) => Ok(Self::RecordPat(Box::new(it.try_into()?))),
            super::nodes::Pat::RefPat(it) => Ok(Self::RefPat(Box::new(it.try_into()?))),
            super::nodes::Pat::SlicePat(it) => Ok(Self::SlicePat(Box::new(it.try_into()?))),
            super::nodes::Pat::TuplePat(it) => Ok(Self::TuplePat(Box::new(it.try_into()?))),
            super::nodes::Pat::TupleStructPat(it) => {
                Ok(Self::TupleStructPat(Box::new(it.try_into()?)))
            }
            super::nodes::Pat::ConstBlockPat(it) => {
                Ok(Self::ConstBlockPat(Box::new(it.try_into()?)))
            }
        }
    }
}
impl TryFrom<super::nodes::FieldList> for FieldList {
    type Error = String;
    fn try_from(item: super::nodes::FieldList) -> Result<Self, Self::Error> {
        match item {
            super::nodes::FieldList::RecordFieldList(it) => {
                Ok(Self::RecordFieldList(Box::new(it.try_into()?)))
            }
            super::nodes::FieldList::TupleFieldList(it) => {
                Ok(Self::TupleFieldList(Box::new(it.try_into()?)))
            }
        }
    }
}
impl TryFrom<super::nodes::Adt> for Adt {
    type Error = String;
    fn try_from(item: super::nodes::Adt) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Adt::Enum(it) => Ok(Self::Enum(Box::new(it.try_into()?))),
            super::nodes::Adt::Struct(it) => Ok(Self::Struct(Box::new(it.try_into()?))),
            super::nodes::Adt::Union(it) => Ok(Self::Union(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::AssocItem> for AssocItem {
    type Error = String;
    fn try_from(item: super::nodes::AssocItem) -> Result<Self, Self::Error> {
        match item {
            super::nodes::AssocItem::Const(it) => Ok(Self::Const(Box::new(it.try_into()?))),
            super::nodes::AssocItem::Fn(it) => Ok(Self::Fn(Box::new(it.try_into()?))),
            super::nodes::AssocItem::MacroCall(it) => Ok(Self::MacroCall(Box::new(it.try_into()?))),
            super::nodes::AssocItem::TypeAlias(it) => Ok(Self::TypeAlias(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::ExternItem> for ExternItem {
    type Error = String;
    fn try_from(item: super::nodes::ExternItem) -> Result<Self, Self::Error> {
        match item {
            super::nodes::ExternItem::Fn(it) => Ok(Self::Fn(Box::new(it.try_into()?))),
            super::nodes::ExternItem::MacroCall(it) => {
                Ok(Self::MacroCall(Box::new(it.try_into()?)))
            }
            super::nodes::ExternItem::Static(it) => Ok(Self::Static(Box::new(it.try_into()?))),
            super::nodes::ExternItem::TypeAlias(it) => {
                Ok(Self::TypeAlias(Box::new(it.try_into()?)))
            }
        }
    }
}
impl TryFrom<super::nodes::GenericParam> for GenericParam {
    type Error = String;
    fn try_from(item: super::nodes::GenericParam) -> Result<Self, Self::Error> {
        match item {
            super::nodes::GenericParam::ConstParam(it) => {
                Ok(Self::ConstParam(Box::new(it.try_into()?)))
            }
            super::nodes::GenericParam::LifetimeParam(it) => {
                Ok(Self::LifetimeParam(Box::new(it.try_into()?)))
            }
            super::nodes::GenericParam::TypeParam(it) => {
                Ok(Self::TypeParam(Box::new(it.try_into()?)))
            }
        }
    }
}
impl std::fmt::Display for Name {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if let Some(it) = &self.ident_token {
            s.push_str(&it);
            s.push_str(" ");
        }
        if self.self_token {
            let mut tmp = stringify!(self_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for NameRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if let Some(it) = &self.ident_token {
            s.push_str(&it);
            s.push_str(" ");
        }
        if self.self_token {
            let mut tmp = stringify!(self_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.super_token {
            let mut tmp = stringify!(super_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.crate_token {
            let mut tmp = stringify!(crate_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.Self_token {
            let mut tmp = stringify!(Self_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Lifetime {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if let Some(it) = &self.lifetime_ident_token {
            s.push_str(&it);
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Path {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if let Some(it) = &self.qualifier {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.coloncolon_token {
            let mut tmp = stringify!(coloncolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.segment.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for PathSegment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.coloncolon_token {
            let mut tmp = stringify!(coloncolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name_ref.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_arg_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ret_type {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.l_angle_token {
            let mut tmp = stringify!(l_angle_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.path_type {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.as_token {
            let mut tmp = stringify!(as_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.r_angle_token {
            let mut tmp = stringify!(r_angle_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for GenericArgList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.coloncolon_token {
            let mut tmp = stringify!(coloncolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_angle_token {
            let mut tmp = stringify!(l_angle_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.generic_args.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        if self.r_angle_token {
            let mut tmp = stringify!(r_angle_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RetType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.thin_arrow_token {
            let mut tmp = stringify!(thin_arrow_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.tracked_token {
            let mut tmp = stringify!(tracked_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for PathType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TypeArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for AssocTypeArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.name_ref.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_arg_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ret_type {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.type_bound_list.to_string());
        s.push_str(" ");
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        if let Some(it) = &self.const_arg {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for LifetimeArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.lifetime.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ConstArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TypeBoundList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.bounds.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroCall {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        if self.excl_token {
            let mut tmp = stringify!(excl_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.token_tree.to_string());
        s.push_str(" ");
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Attr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.pound_token {
            let mut tmp = stringify!(pound_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.excl_token {
            let mut tmp = stringify!(excl_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.meta.to_string());
        s.push_str(" ");
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TokenTree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroItems {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.items.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroStmts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(
            &self.statements.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for SourceFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.shebang_token {
            let mut tmp = stringify!(shebang_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.items.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Const {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.default_token {
            let mut tmp = stringify!(default_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.name {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.underscore_token {
            let mut tmp = stringify!(underscore_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.body {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Enum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.enum_token {
            let mut tmp = stringify!(enum_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.variant_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ExternBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.unsafe_token {
            let mut tmp = stringify!(unsafe_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.abi.to_string());
        s.push_str(" ");
        s.push_str(&self.extern_item_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ExternCrate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.extern_token {
            let mut tmp = stringify!(extern_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.crate_token {
            let mut tmp = stringify!(crate_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name_ref.to_string());
        s.push_str(" ");
        if let Some(it) = &self.rename {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Fn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.publish {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.default_token {
            let mut tmp = stringify!(default_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.async_token {
            let mut tmp = stringify!(async_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.unsafe_token {
            let mut tmp = stringify!(unsafe_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.abi {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.fn_mode {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.fn_token {
            let mut tmp = stringify!(fn_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ret_type {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.requires_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.recommends_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ensures_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.decreases_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.body {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Impl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.default_token {
            let mut tmp = stringify!(default_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.unsafe_token {
            let mut tmp = stringify!(unsafe_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.impl_token {
            let mut tmp = stringify!(impl_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.excl_token {
            let mut tmp = stringify!(excl_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.for_token {
            let mut tmp = stringify!(for_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.assoc_item_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroRules {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.macro_rules_token {
            let mut tmp = stringify!(macro_rules_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.excl_token {
            let mut tmp = stringify!(excl_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        s.push_str(&self.token_tree.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroDef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.macro_token {
            let mut tmp = stringify!(macro_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.args {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.body.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Module {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.mod_token {
            let mut tmp = stringify!(mod_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.item_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Static {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.static_token {
            let mut tmp = stringify!(static_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.mut_token {
            let mut tmp = stringify!(mut_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.body {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Struct {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.data_mode {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.struct_token {
            let mut tmp = stringify!(struct_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.field_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Trait {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.unsafe_token {
            let mut tmp = stringify!(unsafe_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.auto_token {
            let mut tmp = stringify!(auto_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.trait_token {
            let mut tmp = stringify!(trait_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.type_bound_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.assoc_item_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TraitAlias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.trait_token {
            let mut tmp = stringify!(trait_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.type_bound_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TypeAlias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.default_token {
            let mut tmp = stringify!(default_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.type_token {
            let mut tmp = stringify!(type_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.type_bound_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Union {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.union_token {
            let mut tmp = stringify!(union_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.record_field_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Use {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.use_token {
            let mut tmp = stringify!(use_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.use_tree.to_string());
        s.push_str(" ");
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Visibility {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.pub_token {
            let mut tmp = stringify!(pub_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.in_token {
            let mut tmp = stringify!(in_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.path {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ItemList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.items.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Rename {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.as_token {
            let mut tmp = stringify!(as_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.name {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.underscore_token {
            let mut tmp = stringify!(underscore_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for UseTree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if let Some(it) = &self.path {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.coloncolon_token {
            let mut tmp = stringify!(coloncolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.star_token {
            let mut tmp = stringify!(star_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.use_tree_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.rename {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for UseTreeList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.use_trees.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Publish {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.closed_token {
            let mut tmp = stringify!(closed_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.open_token {
            let mut tmp = stringify!(open_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Abi {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.extern_token {
            let mut tmp = stringify!(extern_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for FnMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.spec_token {
            let mut tmp = stringify!(spec_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.proof_token {
            let mut tmp = stringify!(proof_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.exec_token {
            let mut tmp = stringify!(exec_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.mode_spec_checked {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for GenericParamList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_angle_token {
            let mut tmp = stringify!(l_angle_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.generic_params.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        if self.r_angle_token {
            let mut tmp = stringify!(r_angle_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for WhereClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.where_token {
            let mut tmp = stringify!(where_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.predicates.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RequiresClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.requires_token {
            let mut tmp = stringify!(requires_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecommendsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.recommends_token {
            let mut tmp = stringify!(recommends_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.via_token {
            let mut tmp = stringify!(via_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for EnsuresClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.ensures_token {
            let mut tmp = stringify!(ensures_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for DecreasesClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.decreases_token {
            let mut tmp = stringify!(decreases_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for BlockExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.label {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.try_token {
            let mut tmp = stringify!(try_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.unsafe_token {
            let mut tmp = stringify!(unsafe_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.async_token {
            let mut tmp = stringify!(async_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.stmt_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for SelfParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.amp_token {
            let mut tmp = stringify!(amp_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.lifetime {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.mut_token {
            let mut tmp = stringify!(mut_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Param {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.tracked_token {
            let mut tmp = stringify!(tracked_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.dotdotdot_token {
            let mut tmp = stringify!(dotdotdot_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for DataMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.ghost_token {
            let mut tmp = stringify!(ghost_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.tracked_token {
            let mut tmp = stringify!(tracked_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecordFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TupleFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecordField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.data_mode {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TupleField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for VariantList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.variants.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Variant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.field_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for AssocItemList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(
            &self.assoc_items.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ExternItemList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(
            &self.extern_items.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ConstParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.default_val {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for LifetimeParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.lifetime.to_string());
        s.push_str(" ");
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.type_bound_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TypeParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.type_bound_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.default_type {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for WherePred {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.for_token {
            let mut tmp = stringify!(for_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.lifetime {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.type_bound_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Meta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.token_tree {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ExprStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for LetStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.let_token {
            let mut tmp = stringify!(let_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.ghost_token {
            let mut tmp = stringify!(ghost_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.tracked_token {
            let mut tmp = stringify!(tracked_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.initializer.to_string());
        s.push_str(" ");
        if let Some(it) = &self.let_else {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for LetElse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.else_token {
            let mut tmp = stringify!(else_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.block_expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ArrayExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for AwaitExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.dot_token {
            let mut tmp = stringify!(dot_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.await_token {
            let mut tmp = stringify!(await_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for BoxExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.box_token {
            let mut tmp = stringify!(box_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for BreakExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.break_token {
            let mut tmp = stringify!(break_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.lifetime {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for CallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        s.push_str(&self.arg_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for CastExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.as_token {
            let mut tmp = stringify!(as_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ClosureExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.for_token {
            let mut tmp = stringify!(for_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.static_token {
            let mut tmp = stringify!(static_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.async_token {
            let mut tmp = stringify!(async_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.move_token {
            let mut tmp = stringify!(move_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.forall_token {
            let mut tmp = stringify!(forall_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.exists_token {
            let mut tmp = stringify!(exists_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ret_type {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.body.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ContinueExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.continue_token {
            let mut tmp = stringify!(continue_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.lifetime {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for FieldExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.dot_token {
            let mut tmp = stringify!(dot_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name_ref.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ForExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.label {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.for_token {
            let mut tmp = stringify!(for_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.in_token {
            let mut tmp = stringify!(in_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.loop_body.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for IndexExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for LoopExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.label {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.loop_token {
            let mut tmp = stringify!(loop_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.loop_body.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.macro_call.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MatchExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.match_token {
            let mut tmp = stringify!(match_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        s.push_str(&self.match_arm_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MethodCallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.receiver.to_string());
        s.push_str(" ");
        if self.dot_token {
            let mut tmp = stringify!(dot_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name_ref.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_arg_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.arg_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ParenExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for PathExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for PrefixExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RangeExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecordExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        s.push_str(&self.record_expr_field_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RefExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.amp_token {
            let mut tmp = stringify!(amp_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.raw_token {
            let mut tmp = stringify!(raw_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.mut_token {
            let mut tmp = stringify!(mut_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ReturnExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.return_token {
            let mut tmp = stringify!(return_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.question_mark_token {
            let mut tmp = stringify!(question_mark_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TupleExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for WhileExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.label {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.while_token {
            let mut tmp = stringify!(while_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.invariant_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.decreases_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.loop_body.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for YieldExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.yield_token {
            let mut tmp = stringify!(yield_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for YeetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.do_token {
            let mut tmp = stringify!(do_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.yeet_token {
            let mut tmp = stringify!(yeet_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for LetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.let_token {
            let mut tmp = stringify!(let_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for UnderscoreExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.underscore_token {
            let mut tmp = stringify!(underscore_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ViewExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.at_token {
            let mut tmp = stringify!(at_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for AssertExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.assert_token {
            let mut tmp = stringify!(assert_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.by_token {
            let mut tmp = stringify!(by_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.name {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.requires_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.block_expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for AssumeExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.assume_token {
            let mut tmp = stringify!(assume_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for AssertForallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.assert_token {
            let mut tmp = stringify!(assert_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.forall_token {
            let mut tmp = stringify!(forall_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.closure_expr.to_string());
        s.push_str(" ");
        if self.implies_token {
            let mut tmp = stringify!(implies_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.by_token {
            let mut tmp = stringify!(by_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.block_expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for StmtList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(
            &self.statements.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        if let Some(it) = &self.tail_expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Label {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.lifetime.to_string());
        s.push_str(" ");
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecordExprFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.dotdot_token {
            let mut tmp = stringify!(dotdot_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.spread {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecordExprField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.name_ref {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for InvariantClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.invariant_token {
            let mut tmp = stringify!(invariant_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MatchArmList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.arms.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MatchArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.guard {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.fat_arrow_token {
            let mut tmp = stringify!(fat_arrow_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.comma_token {
            let mut tmp = stringify!(comma_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MatchGuard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.if_token {
            let mut tmp = stringify!(if_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ArrayType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for DynTraitType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.dyn_token {
            let mut tmp = stringify!(dyn_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.type_bound_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for FnPtrType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.async_token {
            let mut tmp = stringify!(async_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.unsafe_token {
            let mut tmp = stringify!(unsafe_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.abi {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.fn_token {
            let mut tmp = stringify!(fn_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ret_type {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ForType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.for_token {
            let mut tmp = stringify!(for_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.generic_param_list.to_string());
        s.push_str(" ");
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ImplTraitType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.impl_token {
            let mut tmp = stringify!(impl_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.type_bound_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for InferType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.underscore_token {
            let mut tmp = stringify!(underscore_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.macro_call.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for NeverType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.excl_token {
            let mut tmp = stringify!(excl_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ParenType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for PtrType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.star_token {
            let mut tmp = stringify!(star_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.mut_token {
            let mut tmp = stringify!(mut_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RefType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.amp_token {
            let mut tmp = stringify!(amp_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.lifetime {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.mut_token {
            let mut tmp = stringify!(mut_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for SliceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TupleType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TypeBound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if let Some(it) = &self.lifetime {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.question_mark_token {
            let mut tmp = stringify!(question_mark_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.tilde_token {
            let mut tmp = stringify!(tilde_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.ty.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for IdentPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.ref_token {
            let mut tmp = stringify!(ref_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.mut_token {
            let mut tmp = stringify!(mut_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if self.at_token {
            let mut tmp = stringify!(at_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for BoxPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.box_token {
            let mut tmp = stringify!(box_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RestPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.dotdot_token {
            let mut tmp = stringify!(dotdot_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for LiteralPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.minus_token {
            let mut tmp = stringify!(minus_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.literal.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.macro_call.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for OrPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.pats.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ParenPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for PathPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for WildcardPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.underscore_token {
            let mut tmp = stringify!(underscore_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RangePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecordPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        s.push_str(&self.record_pat_field_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RefPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.amp_token {
            let mut tmp = stringify!(amp_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.mut_token {
            let mut tmp = stringify!(mut_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for SlicePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.pats.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TuplePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TupleStructPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ConstBlockPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.block_expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecordPatFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.rest_pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecordPatField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.name_ref {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ModeSpecChecked {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.spec_token {
            let mut tmp = stringify!(spec_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.checked_token {
            let mut tmp = stringify!(checked_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for SignatureDecreases {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.decreases_clause.to_string());
        s.push_str(" ");
        if self.when_token {
            let mut tmp = stringify!(when_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.via_token {
            let mut tmp = stringify!(via_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Prover {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.by_token {
            let mut tmp = stringify!(by_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TriggerAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.pound_token {
            let mut tmp = stringify!(pound_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.excl_token {
            let mut tmp = stringify!(excl_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.trigger_token {
            let mut tmp = stringify!(trigger_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for GenericArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GenericArg::TypeArg(it) => write!(f, "{}", it.to_string()),
            GenericArg::AssocTypeArg(it) => write!(f, "{}", it.to_string()),
            GenericArg::LifetimeArg(it) => write!(f, "{}", it.to_string()),
            GenericArg::ConstArg(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Type::ArrayType(it) => write!(f, "{}", it.to_string()),
            Type::DynTraitType(it) => write!(f, "{}", it.to_string()),
            Type::FnPtrType(it) => write!(f, "{}", it.to_string()),
            Type::ForType(it) => write!(f, "{}", it.to_string()),
            Type::ImplTraitType(it) => write!(f, "{}", it.to_string()),
            Type::InferType(it) => write!(f, "{}", it.to_string()),
            Type::MacroType(it) => write!(f, "{}", it.to_string()),
            Type::NeverType(it) => write!(f, "{}", it.to_string()),
            Type::ParenType(it) => write!(f, "{}", it.to_string()),
            Type::PathType(it) => write!(f, "{}", it.to_string()),
            Type::PtrType(it) => write!(f, "{}", it.to_string()),
            Type::RefType(it) => write!(f, "{}", it.to_string()),
            Type::SliceType(it) => write!(f, "{}", it.to_string()),
            Type::TupleType(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Expr::ArrayExpr(it) => write!(f, "{}", it.to_string()),
            Expr::AwaitExpr(it) => write!(f, "{}", it.to_string()),
            Expr::BinExpr(it) => write!(f, "{}", it.to_string()),
            Expr::BlockExpr(it) => write!(f, "{}", it.to_string()),
            Expr::BoxExpr(it) => write!(f, "{}", it.to_string()),
            Expr::BreakExpr(it) => write!(f, "{}", it.to_string()),
            Expr::CallExpr(it) => write!(f, "{}", it.to_string()),
            Expr::CastExpr(it) => write!(f, "{}", it.to_string()),
            Expr::ClosureExpr(it) => write!(f, "{}", it.to_string()),
            Expr::ContinueExpr(it) => write!(f, "{}", it.to_string()),
            Expr::FieldExpr(it) => write!(f, "{}", it.to_string()),
            Expr::ForExpr(it) => write!(f, "{}", it.to_string()),
            Expr::IfExpr(it) => write!(f, "{}", it.to_string()),
            Expr::IndexExpr(it) => write!(f, "{}", it.to_string()),
            Expr::Literal(it) => write!(f, "{}", it.to_string()),
            Expr::LoopExpr(it) => write!(f, "{}", it.to_string()),
            Expr::MacroExpr(it) => write!(f, "{}", it.to_string()),
            Expr::MatchExpr(it) => write!(f, "{}", it.to_string()),
            Expr::MethodCallExpr(it) => write!(f, "{}", it.to_string()),
            Expr::ParenExpr(it) => write!(f, "{}", it.to_string()),
            Expr::PathExpr(it) => write!(f, "{}", it.to_string()),
            Expr::PrefixExpr(it) => write!(f, "{}", it.to_string()),
            Expr::RangeExpr(it) => write!(f, "{}", it.to_string()),
            Expr::RecordExpr(it) => write!(f, "{}", it.to_string()),
            Expr::RefExpr(it) => write!(f, "{}", it.to_string()),
            Expr::ReturnExpr(it) => write!(f, "{}", it.to_string()),
            Expr::TryExpr(it) => write!(f, "{}", it.to_string()),
            Expr::TupleExpr(it) => write!(f, "{}", it.to_string()),
            Expr::WhileExpr(it) => write!(f, "{}", it.to_string()),
            Expr::YieldExpr(it) => write!(f, "{}", it.to_string()),
            Expr::YeetExpr(it) => write!(f, "{}", it.to_string()),
            Expr::LetExpr(it) => write!(f, "{}", it.to_string()),
            Expr::UnderscoreExpr(it) => write!(f, "{}", it.to_string()),
            Expr::ViewExpr(it) => write!(f, "{}", it.to_string()),
            Expr::AssertExpr(it) => write!(f, "{}", it.to_string()),
            Expr::AssumeExpr(it) => write!(f, "{}", it.to_string()),
            Expr::AssertForallExpr(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for Item {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Item::Const(it) => write!(f, "{}", it.to_string()),
            Item::Enum(it) => write!(f, "{}", it.to_string()),
            Item::ExternBlock(it) => write!(f, "{}", it.to_string()),
            Item::ExternCrate(it) => write!(f, "{}", it.to_string()),
            Item::Fn(it) => write!(f, "{}", it.to_string()),
            Item::Impl(it) => write!(f, "{}", it.to_string()),
            Item::MacroCall(it) => write!(f, "{}", it.to_string()),
            Item::MacroRules(it) => write!(f, "{}", it.to_string()),
            Item::MacroDef(it) => write!(f, "{}", it.to_string()),
            Item::Module(it) => write!(f, "{}", it.to_string()),
            Item::Static(it) => write!(f, "{}", it.to_string()),
            Item::Struct(it) => write!(f, "{}", it.to_string()),
            Item::Trait(it) => write!(f, "{}", it.to_string()),
            Item::TraitAlias(it) => write!(f, "{}", it.to_string()),
            Item::TypeAlias(it) => write!(f, "{}", it.to_string()),
            Item::Union(it) => write!(f, "{}", it.to_string()),
            Item::Use(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for Stmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Stmt::ExprStmt(it) => write!(f, "{}", it.to_string()),
            Stmt::Item(it) => write!(f, "{}", it.to_string()),
            Stmt::LetStmt(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for Pat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Pat::IdentPat(it) => write!(f, "{}", it.to_string()),
            Pat::BoxPat(it) => write!(f, "{}", it.to_string()),
            Pat::RestPat(it) => write!(f, "{}", it.to_string()),
            Pat::LiteralPat(it) => write!(f, "{}", it.to_string()),
            Pat::MacroPat(it) => write!(f, "{}", it.to_string()),
            Pat::OrPat(it) => write!(f, "{}", it.to_string()),
            Pat::ParenPat(it) => write!(f, "{}", it.to_string()),
            Pat::PathPat(it) => write!(f, "{}", it.to_string()),
            Pat::WildcardPat(it) => write!(f, "{}", it.to_string()),
            Pat::RangePat(it) => write!(f, "{}", it.to_string()),
            Pat::RecordPat(it) => write!(f, "{}", it.to_string()),
            Pat::RefPat(it) => write!(f, "{}", it.to_string()),
            Pat::SlicePat(it) => write!(f, "{}", it.to_string()),
            Pat::TuplePat(it) => write!(f, "{}", it.to_string()),
            Pat::TupleStructPat(it) => write!(f, "{}", it.to_string()),
            Pat::ConstBlockPat(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for FieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FieldList::RecordFieldList(it) => write!(f, "{}", it.to_string()),
            FieldList::TupleFieldList(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for Adt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Adt::Enum(it) => write!(f, "{}", it.to_string()),
            Adt::Struct(it) => write!(f, "{}", it.to_string()),
            Adt::Union(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for AssocItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AssocItem::Const(it) => write!(f, "{}", it.to_string()),
            AssocItem::Fn(it) => write!(f, "{}", it.to_string()),
            AssocItem::MacroCall(it) => write!(f, "{}", it.to_string()),
            AssocItem::TypeAlias(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for ExternItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ExternItem::Fn(it) => write!(f, "{}", it.to_string()),
            ExternItem::MacroCall(it) => write!(f, "{}", it.to_string()),
            ExternItem::Static(it) => write!(f, "{}", it.to_string()),
            ExternItem::TypeAlias(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for GenericParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GenericParam::ConstParam(it) => write!(f, "{}", it.to_string()),
            GenericParam::LifetimeParam(it) => write!(f, "{}", it.to_string()),
            GenericParam::TypeParam(it) => write!(f, "{}", it.to_string()),
        }
    }
}
