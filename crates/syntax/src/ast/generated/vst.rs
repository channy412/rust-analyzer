//! Generated by `sourcegen_vst`, do not edit by hand.

#![allow(non_snake_case)]
use crate::{
    ast::{self, support, AstChildren, AstNode},
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
};
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameRef {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Lifetime {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Path {
    pub qualifier: Option<Box<Path>>,
    pub segment: Option<Box<PathSegment>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathSegment {
    pub name_ref: Option<Box<NameRef>>,
    pub generic_arg_list: Option<Box<GenericArgList>>,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    pub path_type: Option<Box<PathType>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GenericArgList {
    pub generic_args: Vec<GenericArg>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParamList {
    pub self_param: Option<Box<SelfParam>>,
    pub params: Vec<Param>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RetType {
    pub pat: Option<Box<Pat>>,
    pub ty: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathType {
    pub path: Option<Box<Path>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeArg {
    pub ty: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssocTypeArg {
    pub name_ref: Option<Box<NameRef>>,
    pub generic_arg_list: Option<Box<GenericArgList>>,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    pub ty: Option<Box<Type>>,
    pub const_arg: Option<Box<ConstArg>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LifetimeArg {
    pub lifetime: Option<Box<Lifetime>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstArg {
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeBoundList {
    pub bounds: Vec<TypeBound>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroCall {
    pub path: Option<Box<Path>>,
    pub token_tree: Option<Box<TokenTree>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Attr {
    pub meta: Option<Box<Meta>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TokenTree {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroItems {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroStmts {
    pub statements: Vec<Stmt>,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Const {
    pub ty: Option<Box<Type>>,
    pub body: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Enum {
    pub variant_list: Option<Box<VariantList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternBlock {
    pub abi: Option<Box<Abi>>,
    pub extern_item_list: Option<Box<ExternItemList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternCrate {
    pub name_ref: Option<Box<NameRef>>,
    pub rename: Option<Box<Rename>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Fn {
    pub publish: Option<Box<Publish>>,
    pub abi: Option<Box<Abi>>,
    pub fn_mode: Option<Box<FnMode>>,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    pub requires_clause: Option<Box<RequiresClause>>,
    pub recommends_clause: Option<Box<RecommendsClause>>,
    pub ensures_clause: Option<Box<EnsuresClause>>,
    pub decreases_clause: Option<Box<DecreasesClause>>,
    pub body: Option<Box<BlockExpr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Impl {
    pub assoc_item_list: Option<Box<AssocItemList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroRules {
    pub token_tree: Option<Box<TokenTree>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroDef {
    pub args: Option<Box<TokenTree>>,
    pub body: Option<Box<TokenTree>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Module {
    pub item_list: Option<Box<ItemList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Static {
    pub ty: Option<Box<Type>>,
    pub body: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Struct {
    pub data_mode: Option<Box<DataMode>>,
    pub field_list: Option<Box<FieldList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Trait {
    pub assoc_item_list: Option<Box<AssocItemList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TraitAlias {
    pub type_bound_list: Option<Box<TypeBoundList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeAlias {
    pub ty: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Union {
    pub record_field_list: Option<Box<RecordFieldList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Use {
    pub use_tree: Option<Box<UseTree>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Visibility {
    pub path: Option<Box<Path>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ItemList {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Rename {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseTree {
    pub path: Option<Box<Path>>,
    pub use_tree_list: Option<Box<UseTreeList>>,
    pub rename: Option<Box<Rename>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseTreeList {
    pub use_trees: Vec<UseTree>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Publish {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Abi {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnMode {
    pub mode_spec_checked: Option<Box<ModeSpecChecked>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GenericParamList {
    pub generic_params: Vec<GenericParam>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhereClause {
    pub predicates: Vec<WherePred>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RequiresClause {
    pub exprs: Vec<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecommendsClause {
    pub exprs: Vec<Expr>,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnsuresClause {
    pub exprs: Vec<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DecreasesClause {
    pub exprs: Vec<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockExpr {
    pub label: Option<Box<Label>>,
    pub stmt_list: Option<Box<StmtList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelfParam {
    pub lifetime: Option<Box<Lifetime>>,
    pub ty: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Param {
    pub pat: Option<Box<Pat>>,
    pub ty: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DataMode {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordFieldList {
    pub fields: Vec<RecordField>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleFieldList {
    pub fields: Vec<TupleField>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordField {
    pub data_mode: Option<Box<DataMode>>,
    pub ty: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleField {
    pub ty: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariantList {
    pub variants: Vec<Variant>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Variant {
    pub field_list: Option<Box<FieldList>>,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssocItemList {
    pub assoc_items: Vec<AssocItem>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternItemList {
    pub extern_items: Vec<ExternItem>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstParam {
    pub ty: Option<Box<Type>>,
    pub default_val: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LifetimeParam {
    pub lifetime: Option<Box<Lifetime>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParam {
    pub default_type: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WherePred {
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub lifetime: Option<Box<Lifetime>>,
    pub ty: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Meta {
    pub path: Option<Box<Path>>,
    pub expr: Option<Box<Expr>>,
    pub token_tree: Option<Box<TokenTree>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetStmt {
    pub pat: Option<Box<Pat>>,
    pub ty: Option<Box<Type>>,
    pub initializer: Option<Box<Expr>>,
    pub let_else: Option<Box<LetElse>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetElse {
    pub block_expr: Option<Box<BlockExpr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayExpr {
    pub exprs: Vec<Expr>,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AwaitExpr {
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BoxExpr {
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakExpr {
    pub lifetime: Option<Box<Lifetime>>,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExpr {
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CastExpr {
    pub expr: Option<Box<Expr>>,
    pub ty: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClosureExpr {
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    pub body: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueExpr {
    pub lifetime: Option<Box<Lifetime>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FieldExpr {
    pub expr: Option<Box<Expr>>,
    pub name_ref: Option<Box<NameRef>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForExpr {
    pub pat: Option<Box<Pat>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfExpr {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LoopExpr {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroExpr {
    pub macro_call: Option<Box<MacroCall>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchExpr {
    pub expr: Option<Box<Expr>>,
    pub match_arm_list: Option<Box<MatchArmList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodCallExpr {
    pub receiver: Option<Box<Expr>>,
    pub name_ref: Option<Box<NameRef>>,
    pub generic_arg_list: Option<Box<GenericArgList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr {
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathExpr {
    pub path: Option<Box<Path>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr {
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExpr {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordExpr {
    pub path: Option<Box<Path>>,
    pub record_expr_field_list: Option<Box<RecordExprFieldList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefExpr {
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnExpr {
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryExpr {
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleExpr {
    pub fields: Vec<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr {
    pub invariant_clause: Option<Box<InvariantClause>>,
    pub decreases_clause: Option<Box<DecreasesClause>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct YieldExpr {
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct YeetExpr {
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetExpr {
    pub pat: Option<Box<Pat>>,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnderscoreExpr {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ViewExpr {
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssertExpr {
    pub expr: Option<Box<Expr>>,
    pub requires_clause: Option<Box<RequiresClause>>,
    pub block_expr: Option<Box<BlockExpr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssumeExpr {
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssertForallExpr {
    pub closure_expr: Option<Box<ClosureExpr>>,
    pub expr: Option<Box<Expr>>,
    pub block_expr: Option<Box<BlockExpr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StmtList {
    pub statements: Vec<Stmt>,
    pub tail_expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Label {
    pub lifetime: Option<Box<Lifetime>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordExprFieldList {
    pub fields: Vec<RecordExprField>,
    pub spread: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordExprField {
    pub name_ref: Option<Box<NameRef>>,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgList {
    pub args: Vec<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InvariantClause {
    pub exprs: Vec<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArmList {
    pub arms: Vec<MatchArm>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArm {
    pub pat: Option<Box<Pat>>,
    pub guard: Option<Box<MatchGuard>>,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchGuard {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayType {
    pub ty: Option<Box<Type>>,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DynTraitType {
    pub type_bound_list: Option<Box<TypeBoundList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnPtrType {
    pub abi: Option<Box<Abi>>,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForType {
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub ty: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImplTraitType {
    pub type_bound_list: Option<Box<TypeBoundList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InferType {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroType {
    pub macro_call: Option<Box<MacroCall>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NeverType {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenType {
    pub ty: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PtrType {
    pub ty: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefType {
    pub lifetime: Option<Box<Lifetime>>,
    pub ty: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SliceType {
    pub ty: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleType {
    pub fields: Vec<Type>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeBound {
    pub lifetime: Option<Box<Lifetime>>,
    pub ty: Option<Box<Type>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentPat {
    pub pat: Option<Box<Pat>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BoxPat {
    pub pat: Option<Box<Pat>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RestPat {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralPat {
    pub literal: Option<Box<Literal>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroPat {
    pub macro_call: Option<Box<MacroCall>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OrPat {
    pub pats: Vec<Pat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenPat {
    pub pat: Option<Box<Pat>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathPat {
    pub path: Option<Box<Path>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WildcardPat {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangePat {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordPat {
    pub path: Option<Box<Path>>,
    pub record_pat_field_list: Option<Box<RecordPatFieldList>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefPat {
    pub pat: Option<Box<Pat>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SlicePat {
    pub pats: Vec<Pat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TuplePat {
    pub fields: Vec<Pat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleStructPat {
    pub path: Option<Box<Path>>,
    pub fields: Vec<Pat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstBlockPat {
    pub block_expr: Option<Box<BlockExpr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordPatFieldList {
    pub fields: Vec<RecordPatField>,
    pub rest_pat: Option<Box<RestPat>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordPatField {
    pub name_ref: Option<Box<NameRef>>,
    pub pat: Option<Box<Pat>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModeSpecChecked {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SignatureDecreases {
    pub decreases_clause: Option<Box<DecreasesClause>>,
    pub expr: Option<Box<Expr>>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Prover {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TriggerAttribute {
    pub exprs: Vec<Expr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum GenericArg {
    TypeArg(Box<TypeArg>),
    AssocTypeArg(Box<AssocTypeArg>),
    LifetimeArg(Box<LifetimeArg>),
    ConstArg(Box<ConstArg>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    ArrayType(Box<ArrayType>),
    DynTraitType(Box<DynTraitType>),
    FnPtrType(Box<FnPtrType>),
    ForType(Box<ForType>),
    ImplTraitType(Box<ImplTraitType>),
    InferType(Box<InferType>),
    MacroType(Box<MacroType>),
    NeverType(Box<NeverType>),
    ParenType(Box<ParenType>),
    PathType(Box<PathType>),
    PtrType(Box<PtrType>),
    RefType(Box<RefType>),
    SliceType(Box<SliceType>),
    TupleType(Box<TupleType>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    ArrayExpr(Box<ArrayExpr>),
    AwaitExpr(Box<AwaitExpr>),
    BinExpr(Box<BinExpr>),
    BlockExpr(Box<BlockExpr>),
    BoxExpr(Box<BoxExpr>),
    BreakExpr(Box<BreakExpr>),
    CallExpr(Box<CallExpr>),
    CastExpr(Box<CastExpr>),
    ClosureExpr(Box<ClosureExpr>),
    ContinueExpr(Box<ContinueExpr>),
    FieldExpr(Box<FieldExpr>),
    ForExpr(Box<ForExpr>),
    IfExpr(Box<IfExpr>),
    IndexExpr(Box<IndexExpr>),
    Literal(Box<Literal>),
    LoopExpr(Box<LoopExpr>),
    MacroExpr(Box<MacroExpr>),
    MatchExpr(Box<MatchExpr>),
    MethodCallExpr(Box<MethodCallExpr>),
    ParenExpr(Box<ParenExpr>),
    PathExpr(Box<PathExpr>),
    PrefixExpr(Box<PrefixExpr>),
    RangeExpr(Box<RangeExpr>),
    RecordExpr(Box<RecordExpr>),
    RefExpr(Box<RefExpr>),
    ReturnExpr(Box<ReturnExpr>),
    TryExpr(Box<TryExpr>),
    TupleExpr(Box<TupleExpr>),
    WhileExpr(Box<WhileExpr>),
    YieldExpr(Box<YieldExpr>),
    YeetExpr(Box<YeetExpr>),
    LetExpr(Box<LetExpr>),
    UnderscoreExpr(Box<UnderscoreExpr>),
    ViewExpr(Box<ViewExpr>),
    AssertExpr(Box<AssertExpr>),
    AssumeExpr(Box<AssumeExpr>),
    AssertForallExpr(Box<AssertForallExpr>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Item {
    Const(Box<Const>),
    Enum(Box<Enum>),
    ExternBlock(Box<ExternBlock>),
    ExternCrate(Box<ExternCrate>),
    Fn(Box<Fn>),
    Impl(Box<Impl>),
    MacroCall(Box<MacroCall>),
    MacroRules(Box<MacroRules>),
    MacroDef(Box<MacroDef>),
    Module(Box<Module>),
    Static(Box<Static>),
    Struct(Box<Struct>),
    Trait(Box<Trait>),
    TraitAlias(Box<TraitAlias>),
    TypeAlias(Box<TypeAlias>),
    Union(Box<Union>),
    Use(Box<Use>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    ExprStmt(Box<ExprStmt>),
    Item(Box<Item>),
    LetStmt(Box<LetStmt>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Pat {
    IdentPat(Box<IdentPat>),
    BoxPat(Box<BoxPat>),
    RestPat(Box<RestPat>),
    LiteralPat(Box<LiteralPat>),
    MacroPat(Box<MacroPat>),
    OrPat(Box<OrPat>),
    ParenPat(Box<ParenPat>),
    PathPat(Box<PathPat>),
    WildcardPat(Box<WildcardPat>),
    RangePat(Box<RangePat>),
    RecordPat(Box<RecordPat>),
    RefPat(Box<RefPat>),
    SlicePat(Box<SlicePat>),
    TuplePat(Box<TuplePat>),
    TupleStructPat(Box<TupleStructPat>),
    ConstBlockPat(Box<ConstBlockPat>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FieldList {
    RecordFieldList(Box<RecordFieldList>),
    TupleFieldList(Box<TupleFieldList>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Adt {
    Enum(Box<Enum>),
    Struct(Box<Struct>),
    Union(Box<Union>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AssocItem {
    Const(Box<Const>),
    Fn(Box<Fn>),
    MacroCall(Box<MacroCall>),
    TypeAlias(Box<TypeAlias>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ExternItem {
    Fn(Box<Fn>),
    MacroCall(Box<MacroCall>),
    Static(Box<Static>),
    TypeAlias(Box<TypeAlias>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum GenericParam {
    ConstParam(Box<ConstParam>),
    LifetimeParam(Box<LifetimeParam>),
    TypeParam(Box<TypeParam>),
}
