//! various helper functions to interact with proof action cotext
//! 

#![allow(dead_code)]

use crate::{AssistContext, proof_plumber_api::verus_error::*};
use syntax::{
    ast::{self, vst},
    AstNode, SyntaxKind,
};

impl<'a> AssistContext<'a> {
    /// Get TOST node(VST node) from the current cursor position
    /// This is a wrapper around `find_node_at_offset` that returns a TOST node(VST node)
    // REVIEW: to remove type annotation, consider auto-generating all sorts of this function
    pub fn vst_find_node_at_offset<VSTT, CSTT>(&self) -> Option<VSTT>
    where
        VSTT: TryFrom<CSTT>,
        CSTT: AstNode,
    {
        let cst_node: CSTT = self.find_node_at_offset()?;
        VSTT::try_from(cst_node).ok()
    }

    pub fn verus_errors(&self) -> Vec<VerusError> {
        self.verus_errors.clone()
    }

    /// get verus errors generated inside this function
    // note that `pre` uses `pre.callsite` instead of `pre.failing_pre`.
    // technically, the failing pre condition is not the error of that function.
    // it is error of the callsite
    pub fn verus_errors_inside_fn(&self, func: &vst::Fn) -> Option<Vec<VerusError>> {
        let surrounding_fn: &ast::Fn = func.cst.as_ref()?;
        let surrounding_range = surrounding_fn.syntax().text_range();
        let filtered_verus_errs = self
            .verus_errors()
            .into_iter()
            .filter(|verr| match verr {
                VerusError::Pre(pre) => surrounding_range.contains_range(pre.callsite),
                VerusError::Post(post) => surrounding_range.contains_range(post.failing_post),
                VerusError::Assert(assert) => surrounding_range.contains_range(assert.range),
            })
            .collect();
        Some(filtered_verus_errs)
    }

    /// Get precondition failures that was generated by calling this function
    pub fn pre_failures_by_calling_this_fn(&self, func: &vst::Fn) -> Option<Vec<PreFailure>> {
        let surrounding_fn: &ast::Fn = func.cst.as_ref()?;
        let surrounding_range: text_edit::TextRange = surrounding_fn.syntax().text_range();
        let filtered_verus_errs: Vec<VerusError> = self
            .verus_errors()
            .into_iter()
            .filter(|verr| match verr {
                VerusError::Pre(pre) => surrounding_range.contains_range(pre.failing_pre),
                _ => false,
            })
            .collect();
        Some(filter_pre_failuires(&filtered_verus_errs))
    }

    /// Gather every precondition failures
    pub fn pre_failures(&self) -> Vec<PreFailure> {
        filter_pre_failuires(&self.verus_errors)
    }

    /// Gather every postcondition failrues
    pub fn post_failures(&self) -> Vec<PostFailure> {
        filter_post_failuires(&self.verus_errors)
    }

    /// From a Precondition Failure, retreive the TOST expression of the failing predicate
    pub fn expr_from_pre_failure(&self, pre: PreFailure) -> Option<vst::Expr> {
        self.find_node_at_given_range::<syntax::ast::Expr>(pre.failing_pre)?.try_into().ok()
    }

    /// From a Postcondition Failure, retreive the TOST expression of the failing predicate
    pub fn expr_from_post_failure(&self, post: PostFailure) -> Option<vst::Expr> {
        self.find_node_at_given_range::<syntax::ast::Expr>(post.failing_post)?.try_into().ok()
    }

    /// Specify the syntax token to invoke a proof action
    pub fn at_this_token(&self, token: SyntaxKind) -> Option<()> {
        let the_keyword_of_interest = self.find_token_syntax_at_offset(token)?;
        let cursor_in_range = the_keyword_of_interest.text_range().contains_range(self.selection_trimmed());
        if !cursor_in_range {
            return None;
        }
        Some(())
    }

    /// helper routine to replace statement
    pub fn replace_statement<ST0, ST1>(&self, func: &vst::Fn, old: ST0, new: ST1) -> Option<vst::Fn> 
    where
        ST0: Into<vst::Stmt> + std::clone::Clone,
        ST1: Into<vst::Stmt> + std::clone::Clone,
    {
        let old:vst::Stmt = old.into();
        let new:vst::Stmt = new.into();
        let stmts = func.body.as_ref()?.stmt_list.statements.clone(); 
        let mut func = func.clone();
        let replaced_stmts = self.replace_statement_rec(&stmts, old, new);
        func.body.as_mut()?.stmt_list.statements = replaced_stmts;  
        Some(func)
    }

    fn replace_statement_rec(&self, stmts: &Vec<vst::Stmt>, old: vst::Stmt, new: vst::Stmt) -> Vec<vst::Stmt>
    {
        let replaced_stmts: Vec<vst::Stmt> = stmts.into_iter().map(|s| 
            if s.to_string().trim() == old.to_string().trim() {
                new.clone()
            } 
            else {
                if let vst::Stmt::ExprStmt(exprstmt) = s {
                    if let vst::Expr::BlockExpr(be) = &*exprstmt.expr {
                        let inner_stmts = &be.stmt_list.statements;
                        let changed_inner = self.replace_statement_rec(&inner_stmts, old.clone(), new.clone());
                        let mut changed_stmts =vst::StmtList::new();
                        changed_stmts.statements = changed_inner;
                        let changed_exprstmt:vst::Stmt = vst::BlockExpr::new(changed_stmts).into();
                        changed_exprstmt
                    } else {
                        s.clone()
                    }
                } else {
                    s.clone()
                }                
            }).collect();  
        replaced_stmts
    }

    /// helper routine to reduce a list of predicate into &&-ed predicate
    pub fn reduce_exprs(&self, es: Vec<vst::Expr>) -> Option<vst::Expr> {
        es.into_iter().reduce(|acc, e| {
            vst::Expr::BinExpr(Box::new(vst::BinExpr::new(
                acc,
                vst::BinaryOp::LogicOp(ast::LogicOp::And),
                e,
            )))
        })
    }
}
